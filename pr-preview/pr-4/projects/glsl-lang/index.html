<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=color-scheme content="light dark">
<meta name=author content="Vincent Tavernier">
<meta name=description content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL language, with full support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support Full preprocessing support Tested on the glslangValidator test suite   Why not pick this crate?">
<meta name=keywords content="blog,developer,personal,research,graphics">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="glsl-lang">
<meta name=twitter:description content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL language, with full support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support Full preprocessing support Tested on the glslangValidator test suite   Why not pick this crate?">
<meta property="og:title" content="glsl-lang">
<meta property="og:description" content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL language, with full support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support Full preprocessing support Tested on the glslangValidator test suite   Why not pick this crate?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://vtavernier.github.io/pr-preview/pr-4/projects/glsl-lang/"><meta property="article:section" content="projects">
<title>The Tavern</title><link rel=canonical href=https://vtavernier.github.io/pr-preview/pr-4/projects/glsl-lang/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/pr-preview/pr-4/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/pr-preview/pr-4/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/pr-preview/pr-4/css/main.min.eee8b4bae3f8317f1bbbaba644bd5343666fc10948260e11f665c17f082d882c.css integrity="sha256-7ui0uuP4MX8bu6umRL1TQ2ZvwQlIJg4R9mXBfwgtiCw=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/pr-preview/pr-4/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/pr-preview/pr-4/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/pr-preview/pr-4/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/pr-preview/pr-4/images/apple-touch-icon.png>
<link rel=manifest href=/pr-preview/pr-4/site.webmanifest>
<link rel=mask-icon href=/pr-preview/pr-4/images/safari-pinned-tab.svg color=#5bbad5>
<meta name=generator content="Hugo 0.93.3">
</head><body class="preload-transitions colorscheme-dark">
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/pr-preview/pr-4>
The Tavern
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/pr-preview/pr-4/posts/>Blog</a>
</li><li class=navigation-item>
<a class=navigation-link href=/pr-preview/pr-4/projects/>Projects</a>
</li><li class=navigation-item>
<a class=navigation-link href=/pr-preview/pr-4/research/>Research</a>
</li><li class=navigation-item>
<a class=navigation-link href=/pr-preview/pr-4/about/>About me</a>
</li></ul></section></nav><div class=content>
<section class="container page">
<article>
<header>
<h1>
<a href=https://github.com/vtavernier/glsl-lang>glsl-lang</a>
</h1></header><p><a href=https://github.com/vtavernier/glsl-lang/actions target=_blank rel=noopener>
<img src="https://github.com/vtavernier/glsl-lang/workflows/build/badge.svg?branch=master" alt=Build>
</a> <a href=https://crates.io/crates/glsl-lang target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang alt=Crates.io>
</a> <a href=https://docs.rs/glsl-lang/ target=_blank rel=noopener>
<img src=https://img.shields.io/docsrs/glsl-lang alt=docs.rs>
</a> <a href=https://github.com/vtavernier/glsl-lang/blob/master/LICENSE target=_blank rel=noopener>
<img src=https://img.shields.io/github/license/vtavernier/glsl-lang alt=License>
</a></p><p><code>glsl-lang</code> is a crate implementing a LALR parser for the GLSL language, with
full support for preprocessor directives. Its AST and features are modeled
after <a href=https://github.com/phaazon/glsl target=_blank rel=noopener>Dimitri Sabadie&rsquo;s <code>glsl</code> crate</a>.</p><h2 id=table-of-contents>
Table of contents
<a class=heading-link href=#table-of-contents>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><ul>
<li><a href=#repository-structure>Repository structure</a></li><li><a href=#glsl-lang-vs-glsl-crates><code>glsl-lang</code> vs. <code>glsl</code> crates</a>
<ul>
<li><a href=#why-pick-this-crate>Why pick this crate?</a>
<ul>
<li><a href=#its-fast>It&rsquo;s fast</a></li><li><a href=#syntax-nodes-have-location-information>Syntax nodes have location information</a></li><li><a href=#re-written-glsl-transpiler>Re-written GLSL transpiler</a></li><li><a href=#glsl-lang-quote-quoting-support><code>glsl-lang-quote</code> quoting support</a></li><li><a href=#full-preprocessing-support>Full preprocessing support</a></li><li><a href=#tested-on-the-glslangvalidator-test-suite>Tested on the glslangValidator test suite</a></li></ul></li><li><a href=#why-not-pick-this-crate>Why not pick this crate?</a>
<ul>
<li><a href=#stateful-lexer>Stateful lexer</a></li><li><a href=#parser-generation-and-compile-times>Parser generation and compile times</a></li><li><a href=#glsl-lang-quote-state><code>glsl-lang-quote</code> state</a></li><li><a href=#ast-differences>AST differences</a></li><li><a href=#documentation>Documentation</a></li></ul></li></ul></li><li><a href=#limitations>Limitations</a></li><li><a href=#license>License</a></li></ul><h2 id=repository-structure>
Repository structure
<a class=heading-link href=#repository-structure>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><table>
<thead>
<tr>
<th>crates.io</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr>
<td><a href=https://crates.io/crates/glsl-lang target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang target=_blank rel=noopener><code>lang</code></a></td><td>Parser, visitor, transpiler for GLSL language</td></tr><tr>
<td><a href=https://crates.io/crates/glsl-lang-pp target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang-pp alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-pp target=_blank rel=noopener><code>lang-pp</code></a></td><td>standalone preprocessor for the GLSL language</td></tr><tr>
<td><a href=https://crates.io/crates/glsl-lang-lexer target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang-lexer alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-lexer target=_blank rel=noopener><code>lang-lexer</code></a></td><td>Lexers for the GLSL language</td></tr><tr>
<td><a href=https://crates.io/crates/glsl-lang-types target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang-types alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-types target=_blank rel=noopener><code>lang-types</code></a></td><td>AST and shared type definitions for the GLSL language</td></tr><tr>
<td><a href=https://crates.io/crates/glsl-lang-quote target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang-quote alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-quote target=_blank rel=noopener><code>lang-quote</code></a></td><td>proc-macro crate to parse GLSL at compile-time</td></tr><tr>
<td><a href=https://crates.io/crates/glsl-lang-cli target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/glsl-lang-cli alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-cli target=_blank rel=noopener><code>lang-cli</code></a></td><td>simple CLI tool to show GLSL syntax trees</td></tr><tr>
<td><a href=https://crates.io/crates/lang-util target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/lang-util alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-util target=_blank rel=noopener><code>lang-util</code></a></td><td>utilities for implementing syntax trees</td></tr><tr>
<td><a href=https://crates.io/crates/lang-util-derive target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/lang-util-derive alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-util-derive target=_blank rel=noopener><code>lang-util-derive</code></a></td><td>proc-macro crate to implement a syntax tree with span information</td></tr><tr>
<td><a href=https://crates.io/crates/lang-util-dev target=_blank rel=noopener>
<img src=https://img.shields.io/crates/v/lang-util-dev alt=Crates.io>
</a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-util-dev target=_blank rel=noopener><code>lang-util-dev</code></a></td><td>development utilities for parsers implemented using lang-util</td></tr><tr>
<td></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/xtask target=_blank rel=noopener><code>xtask</code></a></td><td>task runner, invoke with <code>cargo xtask</code></td></tr></tbody></table><h2 id=glsl-lang-vs-glsl-crates>
<code>glsl-lang</code> vs. <code>glsl</code> crates
<a class=heading-link href=#glsl-lang-vs-glsl-crates>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><h3 id=why-pick-this-crate>
Why pick this crate?
<a class=heading-link href=#why-pick-this-crate>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><h4 id=its-fast>
It&rsquo;s fast
<a class=heading-link href=#its-fast>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>Due to using a LALR parser and dedicated tokenizer, it&rsquo;s 5-480x (average case
10x) faster than <code>glsl</code>:</p><pre><code>$ cargo bench --bench glsl -- --samples 1000
# Install with `cargo install critcmp`:
$ critcmp new -g '([a-zA-Z0-9._-]*)/\w+'
group                                               new//glsl                               new//glsl_lang
-----                                               ---------                               --------------
preprocessor.extensions.vert                        4.27     24.6±0.09µs     9.9 MB/sec     1.00      5.8±0.05µs    42.5 MB/sec
[...]
300operations.frag                                  10.70  1802.5±4.87µs   836.5 KB/sec     1.00    168.4±1.51µs     8.7 MB/sec
310runtimeArray.vert                                10.32   317.7±0.77µs   965.2 KB/sec     1.00     30.8±0.10µs     9.7 MB/sec
[...]
400.vert                                            13.41     2.8±0.01ms   589.5 KB/sec     1.00    209.1±5.26µs     7.7 MB/sec
[...]
deepRvalue.frag                                     25.90     2.5±0.01ms   351.4 KB/sec     1.00     97.3±0.31µs     8.9 MB/sec
nested_parens                                       483.25     3.6±0.04ms    10.1 KB/sec    1.00      7.4±0.12µs     4.8 MB/sec
</code></pre><h4 id=syntax-nodes-have-location-information>
Syntax nodes have location information
<a class=heading-link href=#syntax-nodes-have-location-information>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>Most nodes in the AST are wrapped in a special <code>Node</code> type, which holds:</p><ul>
<li><code>source_id</code>: an <code>usize</code> to identify which parsing pass produced this node</li><li><code>start</code>: the starting offset of the node in the corresponding input</li><li><code>end</code>: the ending offset of the node in the corresponding input</li></ul><h4 id=re-written-glsl-transpiler>
Re-written GLSL transpiler
<a class=heading-link href=#re-written-glsl-transpiler>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>The GLSL transpiler has been partially rewritten to generate indented code.
It&rsquo;s still a work-in-progress but generates (mostly) readable code.</p><h4 id=glsl-lang-quote-quoting-support>
<code>glsl-lang-quote</code> quoting support
<a class=heading-link href=#glsl-lang-quote-quoting-support>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p><code>glsl-lang-quote</code> is the <code>glsl-lang</code> version of <code>glsl-quasiquote</code>. It parses
GLSL at compile-time to generate an AST. However, you can also insert parts
of runtime-generated AST using a quoting syntax. Currently, the following
insertion locations for the <code>#(rust code)</code> syntax are supported:</p><ul>
<li>Identifier</li><li>Expression</li><li>Function name</li></ul><h4 id=full-preprocessing-support>
Full preprocessing support
<a class=heading-link href=#full-preprocessing-support>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p><code>glsl-lang-pp</code> implements a preprocessor following the GLSL 4.60 language
specification. While this adds a significant amount of complexity,
preprocessing now happens in a proper stage before language parsing, thus
supporting a wider family of inputs.</p><p>Since the preprocessing stage is also responsible for enabling/disabling
extensions and/or pragmas, this allows us to track extra state at the token
granularity.</p><p>The preprocessor also supports include directives:</p><ul>
<li><code>GL_ARB_shading_language_include</code>: run-time includes</li><li><code>GL_GOOGLE_include_directive</code>: compile-time includes</li></ul><p>The preprocessor and lexer based on <code>glsl-lang-pp</code> can be used in <code>glsl-lang</code>
by enabling the <code>glsl-lang/lexer-v2</code> feature. If it is used, the
<code>glsl-lang/lexer-v1</code> feature including the old non-preprocessing lexer can be
disabled.</p><h4 id=tested-on-the-glslangvalidator-test-suite>
Tested on the glslangValidator test suite
<a class=heading-link href=#tested-on-the-glslangvalidator-test-suite>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>The <code>data</code> folder contains vendored test data from the
<a href=https://github.com/KhronosGroup/glslang target=_blank rel=noopener>glslangValidator</a> project to be used
as a reference point for validating the preprocessor and parser.</p><p>The <code>#[test]</code> definitions need to be generate before running the test suite on
the glslang sources. Use the <code>gen-tests</code> task for this:</p><pre><code>cargo xtask gen-tests
</code></pre><p>Then run the tests:</p><pre><code>cargo test --test glslang
</code></pre><p><code>glsl-lang-pp</code> and <code>glsl-lang</code> are tested against this test suite. This is a
snapshot-based test suite which checks the following:</p><ul>
<li><code>glsl-lang-pp</code>: errors, events, preprocessed output and preprocessing AST</li><li><code>glsl-lang</code>: if parsing succeeds, AST, else first parsing error</li></ul><p>Snapshots have not been thoroughly checked, i.e. the <code>glslang</code> test passing for
both crates does not mean we are spec-compliant yet. Please open issues if you
encounter parsing or preprocessing errors.</p><p><code>glslang</code> tests are run during CI but are currently non-fatal. They are used to
track the progress towards a spec-compliant parser.</p><h3 id=why-not-pick-this-crate>
Why not pick this crate?
<a class=heading-link href=#why-not-pick-this-crate>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><h4 id=stateful-lexer>
Stateful lexer
<a class=heading-link href=#stateful-lexer>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>C-based grammar are ambiguous by definition. The main ambiguity being the
inability of the parser to solve conflicts between type names and identifiers
without extra context. Thus, to enable LALR parsing of GLSL, we need to
maintain a list of identifiers that are declared as type names, so the lexer
can properly return <code>IDENT</code> or <code>TYPE_NAME</code> as it is reading the file.</p><p>Depending on your use case, this might prove unwieldy since the parser is not
context-free. Parsing one translation unit followed by another requires
forwarding the type name/identifier disambiguation table to the second pass.</p><h4 id=parser-generation-and-compile-times>
Parser generation and compile times
<a class=heading-link href=#parser-generation-and-compile-times>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>The GLSL grammar is implemented in
<a href=https://github.com/vtavernier/glsl-lang/blob/master/lang/src/parser.lalrpop target=_blank rel=noopener><code>lang/src/parser.lalrpop</code></a> using
<a href=https://github.com/lalrpop/lalrpop target=_blank rel=noopener>LALRPOP</a>. The default feature set only
allows parsing translation units (the top-level rule in the GLSL grammar),
which results in a 25k lines parser file. If you want to include more parsers
(for example for expressions, statements, etc.) you will need to enable the
respective features (<code>parser-expr</code>, <code>parser-statement</code>, etc.) but this will
slow down the compilation of <code>glsl-lang</code> by a significant amount.</p><p>To alleviate this issue, you can use the <code>Parsable</code> trait: by wrapping a syntax
item in a suitable source, and then matching the resulting AST, we can extract
the result of any rule in the grammar. Currently, this interface panics if the
output AST cannot be matched, so don&rsquo;t use it on unknown input. It&rsquo;s fine for
testing though.</p><h4 id=glsl-lang-quote-state>
<code>glsl-lang-quote</code> state
<a class=heading-link href=#glsl-lang-quote-state>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>Parsing preprocessor directives is currently not supported.</p><h4 id=ast-differences>
AST differences
<a class=heading-link href=#ast-differences>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>There are some differences in both crate&rsquo;s ASTs, so porting to <code>glsl-lang</code>
would require some changes to your code:</p><ul>
<li>The <code>Statement/SimpleStatement/CompoundStatement</code> structure was flattened to <code>Statement</code></li><li>The <code>subroutine</code> storage qualifier takes a <code>TypeSpecifier</code> array instead of a <code>TypeName</code> array</li><li><code>FunIdentifier::Identifier</code> was replaced with <code>FunIdentifier::TypeSpecifier</code>:
this reflects the fact that a type specifier as a function identifier is a
constructor, and array specifiers are only allowed in this position.</li><li>The <code>NonEmpty</code> wrapper was removed</li><li><code>Declaration::Global</code> was removed since it&rsquo;s parsed as an <code>InitDeclaratorList</code></li></ul><h4 id=documentation>
Documentation
<a class=heading-link href=#documentation>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>Most items are documented (through <code>#[deny(missing_docs)]</code>) although we are
currently missing some usage examples. These will come soon enough, promise!</p><h2 id=limitations>
Limitations
<a class=heading-link href=#limitations>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><p>Aside from the limitations mentioned in the paragraph above:</p><ul>
<li>Starting with the 0.2 release of <code>glsl-lang</code>, the <code>glsl-lang-pp</code> (also part
of this project) is used to preprocess the input before running the parser.
This means we can now parse shaders that are invalid without macro expansion,
but as a result we lose some preprocessing directives in the AST. Also, since
preprocessing directives can be inserted at any point in the token stream, we
may only recover those which are at the top-level, just like the <code>glsl</code> crate
does.</li><li>Currently, no semantic analysis</li></ul><h2 id=license>
License
<a class=heading-link href=#license>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><p>This work is licensed under the BSD 3-clause license. Lexer and LALR parser by
Vincent Tavernier <a href=https://github.com/vtavernier/glsl-lang/blob/master/mailto:vince.tavernier@gmail.com target=_blank rel=noopener>vince.tavernier@gmail.com</a>. Original AST, test suite and
quoting code by Dimitri Sabadie <a href=https://github.com/vtavernier/glsl-lang/blob/master/mailto:dimitri.sabadie@gmail.com target=_blank rel=noopener>dimitri.sabadie@gmail.com</a>. glslangValidator
test suite from the Khronos group.</p></article></section></div><footer class=footer>
<section class=container>
©
2019 -
2023
Vincent Tavernier
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section></footer></main><script src=/pr-preview/pr-4/js/coder.min.617ac1196e51a8e5820c29ea3f349ae87be7db1242a5a91f3afa569275213d0f.js integrity="sha256-YXrBGW5RqOWCDCnqPzSa6Hvn2xJCpakfOvpWknUhPQ8="></script>
<script src=/pr-preview/pr-4/main.min.4962b2326a84087d9b01e3f7a69cf58ddfbd1efe7fa93c56a847bd4bf8392a4e.js integrity="sha256-SWKyMmqECH2bAeP3ppz1jd+9Hv5/qTxWqEe9S/g5Kk4="></script>
<script data-goatcounter=https://vtavernier.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
</body></html>