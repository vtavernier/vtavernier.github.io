<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Vincent Tavernier"><meta name=description content="The Arduino ecosystem changed the world of DIY electronics, let's take a look under the hood to figure out how that happened."><meta name=keywords content="blog,developer,personal,research,graphics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Arduino Internals â€” What's behind the magic?"><meta name=twitter:description content="The Arduino ecosystem changed the world of DIY electronics, let's take a look under the hood to figure out how that happened."><meta property="og:title" content="Arduino Internals â€” What's behind the magic?"><meta property="og:description" content="The Arduino ecosystem changed the world of DIY electronics, let's take a look under the hood to figure out how that happened."><meta property="og:type" content="article"><meta property="og:url" content="https://vtavernier.github.io/posts/arduino-internals-whats-behind-the-magic/"><meta property="article:published_time" content="2021-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-12T00:00:00+00:00"><title>Arduino Internals â€” What's behind the magic? Â· The Tavern</title><link rel=canonical href=https://vtavernier.github.io/posts/arduino-internals-whats-behind-the-magic/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.eb7743f94930acfd17146aecc1f80e86fe35b3e451f2ec0c98485f9c4d962f34.css integrity="sha256-63dD+UkwrP0XFGrswfgOhv41s+RR8uwMmEhfnE2WLzQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.dde8a61eb31a32353b4baf3d9113f03c4ea2a8ca9bb736f59ca2d2b2cb664f0b.css integrity="sha256-3eimHrMaMjU7S689kRPwPE6iqMqbtzb1nKLSsstmTws=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/main.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.2/twemoji.min.js integrity=sha384-wyB/MspSJ/r2bT2kCj44qtsYRYlpzO2oAPhRj5myrWD63dt6qWv4x8AZe7Fl3K3b crossorigin=anonymous></script><meta name=generator content="Hugo 0.80.0"></head><body class="preload-transitions colorscheme-dark" onload=twemoji.parse(document.body);><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>The Tavern</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/research/>Research</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://vtavernier.github.io/posts/arduino-internals-whats-behind-the-magic/>Arduino Internals â€” What's behind the magic?</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-04-12T00:00:00Z>April 12, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>13-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/tags/arduino/>arduino</a>
<span class=separator>â€¢</span>
<a href=/tags/software/>software</a>
<span class=separator>â€¢</span>
<a href=/tags/electronics/>electronics</a></div></div></header><div><p>Arduino is an open-source software and hardware platform tailored for electronics beginners and enthusiasts alike. Since
the early models' releases (Arduino Diecimila in 2007 and Duemilanove in 2009), they have become ubiquitous to the point
that &ldquo;an Arduino&rdquo; is often used as a synonym for &ldquo;a microcontroller&rdquo;, and have been used in countless projects by makers
around the world.</p><p><figure><img src=Arduino_Duemilanove_2009b.jpg alt="Arduino Duemilanove 2009b"><figcaption>An Arduino Duemilanove. The first Arduino I actually
programmed. Source: <a href=https://commons.wikimedia.org/wiki/File:Arduino_Duemilanove_2009b.jpg target=_blank rel=noopener>Wikipedia</a></figcaption></figure></p><p>What this project actually achieved is simplifying microcontroller programming to the extreme, replacing obscure
datasheet diving and reference implementation diagrams dissection with intuitive function calls <em>mostly</em> portable
across the entire official product range. The &ldquo;hello world&rdquo; of electronics, the blinking LED was simplified from this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#6272a4>// Compile with:       avr-gcc -mmcu=atmega328p -DF_CPU=16000000L
</span><span style=color:#6272a4>// Create binary with: avr-objcopy -O ihex -R .eeprom a.out a.hex
</span><span style=color:#6272a4>// Upload with:        avrdude -p atmega328p -c arduino -P /dev/ttyUSB0 -b 57600 -D -U flash:w:a.hex:i
</span><span style=color:#6272a4>// Only works on the Arduino Uno series, with a 16MHz ÂµC
</span><span style=color:#6272a4></span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;avr/io.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;util/delay.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
  <span style=color:#6272a4>// Set the LED&#39;s pin to output
</span><span style=color:#6272a4></span>  DDRB <span style=color:#ff79c6>|=</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> PB5);

  <span style=color:#ff79c6>while</span> (<span style=color:#bd93f9>1</span>) {
    <span style=color:#6272a4>// Toggle the LED pin state
</span><span style=color:#6272a4></span>    PORTB <span style=color:#ff79c6>^=</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> PB5);
    <span style=color:#6272a4>// Wait
</span><span style=color:#6272a4></span>    _delay_ms(<span style=color:#bd93f9>1000</span>);
  }
}
</code></pre></div><p>To this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#6272a4>// In the Arduino IDE, click &#34;upload&#34;
</span><span style=color:#6272a4>// Portable across all Arduinos which have a built-in LED
</span><span style=color:#6272a4></span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;Arduino.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setup</span>() {
  <span style=color:#6272a4>// Set the LED&#39;s pin to output
</span><span style=color:#6272a4></span>  pinMode(LED_BUILTIN, OUTPUT);
}

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>loop</span>() {
  <span style=color:#6272a4>// Switch on the LED
</span><span style=color:#6272a4></span>  digitalWrite(LED_BUILTIN, HIGH);
  <span style=color:#6272a4>// Wait
</span><span style=color:#6272a4></span>  delay(<span style=color:#bd93f9>1000</span>);
  <span style=color:#6272a4>// Switch off the LED
</span><span style=color:#6272a4></span>  digitalWrite(LED_BUILTIN, LOW);
  <span style=color:#6272a4>// Wait
</span><span style=color:#6272a4></span>  delay(<span style=color:#bd93f9>1000</span>);
}
</code></pre></div><p>Of course, this is just scratching the surface, since opening up the world of microcontrollers to the masses also
sparked a lot of open-source development, and many libraries can be used to interact with the &ldquo;shields&rdquo;, add-ons to the
base Arduino board: <a href=https://store.arduino.cc/arduino-motor-shield-rev3 target=_blank rel=noopener>motor drivers</a>, <a href=https://store.arduino.cc/arduino-ethernet-shield-2 target=_blank rel=noopener>Ethernet
interfaces</a>, <a href=https://store.arduino.cc/arduino-mkr-imu-shield target=_blank rel=noopener>IMUs</a>
and countless others.</p><p>Various <a href=https://www.amazon.com/ELEGOO-Project-Tutorial-Controller-Projects/dp/B01D8KOZF4 target=_blank rel=noopener>starter kits</a> can also be
used if you want to prototype your own circuits with an Arduino Uno compatible board and some standard components, such
as an ultrasonic distance reader, humidity and temperature sensor, 7-segment displays, etc.</p><p>The USB (data and power!) connection on most boards means these are just plug and play: buy an Arduino board from your
favorite reseller, and you can program it from any desktop or laptop PC.</p><p>Recently however, a lot of &ldquo;Arduino-compatible&rdquo; boards started appearing on the market, such as the hugely popular
ESP8266 from Espressif Systems, available on the original <a href=https://en.wikipedia.org/wiki/NodeMCU target=_blank rel=noopener>NodeMCU</a>, but also in
Arduino-Uno <a href=https://www.amazon.com/ARCELI-ESP8266-Development-Compatible-Arduino/dp/B07J2QKNHB/ target=_blank rel=noopener>footprints</a>, with
built-in Wi-Fi capabilities, much more processing power as well as large storage.</p><p><figure><img src=WeMos_D1.jpg alt="WeMos D1"><figcaption>WeMos D1, one of the many ESP8266 boards</figcaption></figure></p><p>Even though those were not initially programmable from the Arduino IDE, the Arduino community added support for these as
they became one of the most go-to choices for IoT projects over the recent years.</p><p>But with such a wide variety of hardware, how does the Arduino platform provide an <em>almost</em> seamless development
experience on AVR, ARM, Xtensa and many other architectures?</p><p>Experienced embedded developers know this means installing various toolchains for cross-compiling, fiddling with linker
scripts to get the right memory layout for your specific board revision, and a bunch of other boring stuff we won&rsquo;t get
to in this article. Instead, we&rsquo;ll be focusing on the software side: what&rsquo;s exactly behind <code>#include &lt;Arduino.h></code> on a
few select platforms, and why we would need to care about it.</p><blockquote><p>All the examples in this article were developed using <a href=https://platformio.org/ target=_blank rel=noopener>PlatformIO</a>, which I highly recommend
instead of the Arduino IDE. Although the recent releases have made huge progress, I prefer the versatility of my text
editor (with <a href=https://github.com/MaskRay/ccls target=_blank rel=noopener>ccls</a> completion) and compiling/uploading with a simple <code>pio run -t upload</code> command.</p></blockquote><h1 id=arduino-framework-architecture>Arduino framework architecture
<a class=heading-link href=#arduino-framework-architecture><i class="fa fa-link" aria-hidden=true></i></a></h1><p>For most software projects, the go-to way for getting information about library internals would be hitting the reference
manual online. In the case of Arduino, it&rsquo;s located at <a href=https://www.arduino.cc/reference/en>https://www.arduino.cc/reference/en</a>. However, it&rsquo;s surprisingly
succint: function signatures included in the documentation don&rsquo;t even show the arguments'
type<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>For a beginner, using the C++ language, whose type conversions are a minefield<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, on a target that doesn&rsquo;t
support debugging (and where buffer overflows result in usually very funny looking output on your serial port monitor)
can lead to many headaches and hours of painful trial and error.</p><p>This reference was also written for the <em>original</em> Arduino boards, i.e. the AVR-based ones. The most notable example is
the <a href=https://www.arduino.cc/reference/en/language/variables/utilities/progmem/ target=_blank rel=noopener><code>PROGMEM</code></a> variable modifier, which is
only available on AVR targets. Trying to use it on non-AVR targets results in a compile-error, unless your code detects
it&rsquo;s being compiled for a non-AVR target.</p><p>The reference documentation also mixes <a href=https://www.arduino.cc/reference/en/#functions target=_blank rel=noopener>standard library functions</a>,
<a href=https://www.arduino.cc/reference/en/#variables target=_blank rel=noopener>plain datatypes and complex ones</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, <a href=https://www.arduino.cc/reference/en/#structure target=_blank rel=noopener>Arduino program
structure and C++ language details</a> on a single page.</p><p><strong>To be absolutely clear:</strong> I am not saying this is a bad thing. This documentation has been written with the clear
intent of being a one-stop point, easy to approach for a beginner, and should be sufficient for hobbyists to get
started, until they are more at ease with electronics and/or software development &mdash; and it accomplishes this goal
rather well. But for more advanced users, it is clearly lacking information about design choices and platform
differences &mdash; a notable issue when promoting Arduino code as platform-independent.</p><p>My goal when writing this article was to share with the world the process I went through to unearth some differences I
noticed when working with various boards (ESP8266, Arduino Nano 33 BLE, ATTiny85-based Digispark and others). So let&rsquo;s
get started!</p><h2 id=whats-arduinoh-exactly>What&rsquo;s <code>Arduino.h</code> exactly?
<a class=heading-link href=#whats-arduinoh-exactly><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Using a new board in the Arduino IDE is as simple as downloading the right <em>core</em> through the <em>board manager</em>. We can
look around starting from a basic sketch to peak at the internals of what this <em>core</em> really is. Starting with
<code>Arduino.h</code>, which all Arduino code should <code>#include</code> to access the standard library functions described in the
reference documentation, using an IDE with code completion<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, we can just ask the editor to open
the header file under our cursor and follow the include graph.</p><p>This will bring up this version of <code>Arduino.h</code> from the core installation path,
<a href=https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/Arduino.h target=_blank rel=noopener><code>$AVR_CORE/cores/arduino/Arduino.h</code></a>,
which already teaches us a lot:</p><ul><li>There&rsquo;s all the constants in the documentation, as <code>#define</code>s, and some functions which are actually implemented as
macros (e.g. <code>min</code> and <code>max</code>).</li><li>Gated behind <code>__cplusplus</code>, includes for some types defined by Wiring, the predecessor of the Arduino framework,
itself based on Processing. The main one being <code>WString.h</code>, defining the <code>String</code> type.</li><li>Some board-specific stuff, like including USB API support or hardware serial support depending on preprocessor
definitions.</li><li>A final include for <code>pins_arduino.h</code>, which contains mappings from Arduino pin numbers (0-13 as what&rsquo;s passed to
<code>digitalWrite</code>) to physical microcontroller pins (<code>PORTB</code>, <code>PORTC</code> registers and others). This one is stored in the
<code>$AVR_CORE/variants/$VARIANT</code> folder: depending on the current board, the right <code>-I</code> flag will be passed to the
compiler to include mappings for the target, for example the Arduino Mega (<code>$VARIANT = mega</code>), or Uno (<code>$VARIANT = standard</code>).</li></ul><p>Noting the dependencies while following along, we can draw a (partial so it fits in a blog post) include graph between
the different components of this core:</p><figure><div class=mermaid>flowchart TB
sketch[Blink.ino] --> arduino_h
subgraph avr_std[AVR Toolchain]
avr_io[avr/io.h]
avr_pgmspace[avr/pgmspace.h]
avr_stdio[stdio.h]
end
subgraph avr_core[Arduino AVR Core]
subgraph cores/arduino
arduino_h[Arduino.h]
arduino_h --> wstring_h[WString.h]
arduino_h --> print_h[Print.h]
arduino_h --> avr_pgmspace
print_h --> avr_stdio
wstring_h --> avr_pgmspace
end
arduino_h -- -I flag --> arduino_pins_h_standard
arduino_h -.-> arduino_pins_h_others
arduino_h --> avr_io
subgraph variants
subgraph standard
arduino_pins_h_standard[arduino_pins.h] ---> avr_io
arduino_pins_h_standard ---> avr_pgmspace
end
subgraph others[...]
arduino_pins_h_others[arduino_pins.h] ---> avr_io
arduino_pins_h_others ---> avr_pgmspace
end
end
end</div><figcaption>Arduino AVR partial include graph</figcaption></figure><p>This <code>Arduino.h</code> is already hardware-specific, even if most of it is hardware-independent. Its definitions follow what
we can see in the reference documentation, but it is definitely <strong>not</strong> portable. It is however shared for all boards
using the same architecture, and maintained by the same entity. In this case, this is the original AVR core, and it&rsquo;s
even available on GitHub, in a sensible location: <a href=https://github.com/arduino/ArduinoCore-avr>https://github.com/arduino/ArduinoCore-avr</a>.</p><p>Let&rsquo;s explore it a bit more: the core also contains the actual implementations of functions from the Arduino framework,
which is what we&rsquo;re after. To keep this short, we will look at <code>digitalWrite</code>, about which there is already a lot to
say.</p><h3 id=arduinos-digitalwrite-on-atmels-avr-platform>Arduino&rsquo;s <code>digitalWrite</code> on Atmel&rsquo;s AVR platform
<a class=heading-link href=#arduinos-digitalwrite-on-atmels-avr-platform><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Using our trusty editor and it&rsquo;s <em>go to implementation</em> feature, we can quickly find it in
<a href=https://github.com/arduino/ArduinoCore-avr/blob/9f8d27f09f3bbd1da1374b5549a82bda55d45d44/cores/arduino/wiring_digital.c#L138 target=_blank rel=noopener><code>wiring_digital.c</code></a>,
in all its microcontroller-programming-simplifying glory:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>digitalWrite</span>(<span style=color:#8be9fd>uint8_t</span> pin, <span style=color:#8be9fd>uint8_t</span> val)
{
	<span style=color:#8be9fd>uint8_t</span> timer <span style=color:#ff79c6>=</span> digitalPinToTimer(pin);
	<span style=color:#8be9fd>uint8_t</span> bit <span style=color:#ff79c6>=</span> digitalPinToBitMask(pin);
	<span style=color:#8be9fd>uint8_t</span> port <span style=color:#ff79c6>=</span> digitalPinToPort(pin);
	<span style=color:#ff79c6>volatile</span> <span style=color:#8be9fd>uint8_t</span> <span style=color:#ff79c6>*</span>out;

	<span style=color:#ff79c6>if</span> (port <span style=color:#ff79c6>==</span> NOT_A_PIN) <span style=color:#ff79c6>return</span>;

	<span style=color:#6272a4>// If the pin that support PWM output, we need to turn it off
</span><span style=color:#6272a4></span>	<span style=color:#6272a4>// before doing a digital write.
</span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> (timer <span style=color:#ff79c6>!=</span> NOT_ON_TIMER) turnOffPWM(timer);

	out <span style=color:#ff79c6>=</span> portOutputRegister(port);

	<span style=color:#8be9fd>uint8_t</span> oldSREG <span style=color:#ff79c6>=</span> SREG;
	cli();

	<span style=color:#ff79c6>if</span> (val <span style=color:#ff79c6>==</span> LOW) {
		<span style=color:#ff79c6>*</span>out <span style=color:#ff79c6>&amp;=</span> <span style=color:#ff79c6>~</span>bit;
	} <span style=color:#ff79c6>else</span> {
		<span style=color:#ff79c6>*</span>out <span style=color:#ff79c6>|=</span> bit;
	}

	SREG <span style=color:#ff79c6>=</span> oldSREG;
}
</code></pre></div><p>To set the logic level of an output pin, <code>digitalWrite</code> actually does the following:</p><ul><li>Check that the given pin is suitable for digital output (the <code>digitalPinTo*</code> family of functions will return <code>NOT_*</code>
sentinel values otherwise)</li><li>Disable hardware PWM on the target pin if it was enabled</li><li>Disable hardware interrupts, set the target value, and then re-enable them</li></ul><p>For a microcontroller running at 16MHz, <code>digitalWrite</code> is a noticeably expensive operation. Indeed, it does:</p><ul><li>3 <code>PROGMEM</code> reads (<code>digitalPinTo*</code> function calls) for <code>timer</code>, <code>bit</code> and <code>port</code>.</li><li>2 branches to validate the pin values. Note that the function fails silently for wrong pin values.</li><li>1 more <code>PROGMEM</code> read for getting the port&rsquo;s output register from its port number <code>port</code>.<br><blockquote><p><em>Note: by this point, all the values in the data flow are returned from reading constant arrays in program memory with
<code>pgm_read_byte</code>. Even though these values should be constant folded if <code>pin</code> and <code>val</code> are themselves constants, the
compiler can&rsquo;t reason enough yet to perform this optimization. Which means the rest of the operations can&rsquo;t be
optimized for constants.</em></p></blockquote></li><li>Disable interrupts<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</li><li>One last branch to determine if a bit should be cleared or set.</li><li>Apply the bitmask: this is a read-modify-write operation, and thus non-atomic, which requires disabled interrupts for
correctness.</li><li>Restore interrupts.</li></ul><p>These multiple levels of indirections are, at the time of writing, <strong>not</strong> optimized away by <code>avr-gcc</code>. The following
Arduino sketch (which only uses constants for both the pin and value):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;Arduino.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setup</span>() { pinMode(LED_BUILTIN, OUTPUT); }

<span style=color:#8be9fd>void</span> <span style=color:#50fa7b>loop</span>() {
  digitalWrite(LED_BUILTIN, HIGH);
  digitalWrite(LED_BUILTIN, LOW);
}
</code></pre></div><p>Compiles to the following assembly<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#bd93f9>000000e0</span> <span style=color:#ff79c6>&lt;</span>digitalWrite.constprop.0<span style=color:#ff79c6>&gt;:</span>
  <span style=color:#6272a4># [truncated: 54 instructions for computing timer, bit, port and other checks]</span>
  <span style=color:#6272a4>#   uint8_t oldSREG = SREG;</span>
 <span style=color:#bd93f9>158</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>9</span>f b7       	in	r25, <span style=color:#bd93f9>0x3f</span>	<span style=color:#6272a4># 63</span>
  <span style=color:#6272a4>#   cli();</span>
 <span style=color:#bd93f9>15</span>a<span style=color:#ff79c6>:</span>	f8 <span style=color:#bd93f9>94</span>       	cli
  <span style=color:#6272a4>#   if (val == LOW) {</span>
 <span style=color:#bd93f9>15</span>c<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>81</span> <span style=color:#bd93f9>11</span>       	cpse	r24, r1
 <span style=color:#bd93f9>15</span>e<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>04</span> c0       	rjmp	.+8      	<span style=color:#6272a4># 0x168 &lt;digitalWrite.constprop.0+0x88&gt;</span>
  <span style=color:#6272a4>#     *out &amp;= ~bit;</span>
 <span style=color:#bd93f9>160</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>8</span>c <span style=color:#bd93f9>91</span>       	ld	r24, X
 <span style=color:#bd93f9>162</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>20</span> <span style=color:#bd93f9>95</span>       	com	r18
 <span style=color:#bd93f9>164</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>28</span> <span style=color:#bd93f9>23</span>       	and	r18, r24
  <span style=color:#6272a4>#   } else {</span>
 <span style=color:#bd93f9>166</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>02</span> c0       	rjmp	.+4      	<span style=color:#6272a4># 0x16c &lt;digitalWrite.constprop.0+0x8c&gt;</span>
  <span style=color:#6272a4>#     *out |= bit;</span>
 <span style=color:#bd93f9>168</span><span style=color:#ff79c6>:</span>	ec <span style=color:#bd93f9>91</span>       	ld	r30, X
 <span style=color:#bd93f9>16</span>a<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>2</span>e <span style=color:#bd93f9>2</span>b       	or	r18, r30
 <span style=color:#bd93f9>16</span>c<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>2</span>c <span style=color:#bd93f9>93</span>       	st	X, r18
  <span style=color:#6272a4>#   }</span>
  <span style=color:#6272a4>#   SREG = oldSREG;</span>
 <span style=color:#bd93f9>16</span>e<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>9</span>f bf       	out	<span style=color:#bd93f9>0x3f</span>, r25	<span style=color:#6272a4># 63</span>
  <span style=color:#6272a4># }</span>
 <span style=color:#bd93f9>170</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>08</span> <span style=color:#bd93f9>95</span>       	ret

<span style=color:#bd93f9>00000206</span> <span style=color:#ff79c6>&lt;</span>main<span style=color:#ff79c6>&gt;:</span>
 <span style=color:#6272a4># [truncated: Arduino framework initialization]</span>
 <span style=color:#6272a4># [truncated: inlined call to pinMode(...) ]</span>

 <span style=color:#6272a4># Note: loop is inlined since it&#39;s only called from Arduino&#39;s main</span>
 <span style=color:#6272a4># digitalWrite(LED_BUILTIN, HIGH);</span>
 <span style=color:#bd93f9>2</span>c6<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>81</span> e0       	ldi	r24, <span style=color:#bd93f9>0x01</span>	<span style=color:#6272a4># 1</span>
 <span style=color:#bd93f9>2</span>c8<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>0</span>e <span style=color:#bd93f9>94</span> <span style=color:#bd93f9>70</span> <span style=color:#bd93f9>00</span> 	call	<span style=color:#bd93f9>0xe0</span>	<span style=color:#6272a4># 0xe0 &lt;digitalWrite.constprop.0&gt;</span>
 <span style=color:#6272a4># digitalWrite(LED_BUILTIN, LOW);</span>
 <span style=color:#bd93f9>2</span>cc<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>80</span> e0       	ldi	r24, <span style=color:#bd93f9>0x00</span>	<span style=color:#6272a4># 0</span>
 <span style=color:#bd93f9>2</span>ce<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>0</span>e <span style=color:#bd93f9>94</span> <span style=color:#bd93f9>70</span> <span style=color:#bd93f9>00</span> 	call	<span style=color:#bd93f9>0xe0</span>	<span style=color:#6272a4># 0xe0 &lt;digitalWrite.constprop.0&gt;</span>
 <span style=color:#6272a4># Note: the following is the Arduino&#39;s while loop around calling loop()</span>
 <span style=color:#bd93f9>2</span>d2<span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>20</span> <span style=color:#bd93f9>97</span>       	sbiw	r28, <span style=color:#bd93f9>0x00</span>	<span style=color:#6272a4># 0</span>
 <span style=color:#bd93f9>2</span>d4<span style=color:#ff79c6>:</span>	c1 f3       	breq	.-16     	<span style=color:#6272a4># 0x2c6 &lt;main+0xc0&gt;</span>

 <span style=color:#6272a4># [truncated: more main code]</span>
</code></pre></div><p>While its equivalent pure-AVR code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;avr/io.h&gt;</span><span style=color:#ff79c6>
</span><span style=color:#ff79c6></span>
<span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>() {
  DDRB <span style=color:#ff79c6>|=</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> PB5);

  <span style=color:#ff79c6>while</span> (<span style=color:#bd93f9>1</span>) {
    PORTB <span style=color:#ff79c6>|=</span> (<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> PB5);
    PORTB <span style=color:#ff79c6>&amp;=</span> <span style=color:#ff79c6>~</span>(<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>&lt;&lt;</span> PB5);
  }
}
</code></pre></div><p>Compiles to the optimal assembly below (<code>sbi</code> sets a specific bit in a port register, and <code>cbi</code> clears it):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#bd93f9>00000080</span> <span style=color:#ff79c6>&lt;</span>main<span style=color:#ff79c6>&gt;:</span>
  <span style=color:#6272a4># DDRB |= (1 &lt;&lt; PB5);</span>
  <span style=color:#bd93f9>80</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>25</span> <span style=color:#bd93f9>9</span>a       	sbi	<span style=color:#bd93f9>0x04</span>, <span style=color:#bd93f9>5</span>	<span style=color:#6272a4># 4</span>
  <span style=color:#6272a4># while (1) {</span>
  <span style=color:#6272a4># PORTB |= (1 &lt;&lt; PB5);</span>
  <span style=color:#bd93f9>82</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>2</span>d <span style=color:#bd93f9>9</span>a       	sbi	<span style=color:#bd93f9>0x05</span>, <span style=color:#bd93f9>5</span>	<span style=color:#6272a4># 5</span>
  <span style=color:#6272a4># PORTB &amp;= ~(1 &lt;&lt; PB5);</span>
  <span style=color:#bd93f9>84</span><span style=color:#ff79c6>:</span>	<span style=color:#bd93f9>2</span>d <span style=color:#bd93f9>98</span>       	cbi	<span style=color:#bd93f9>0x05</span>, <span style=color:#bd93f9>5</span>	<span style=color:#6272a4># 5</span>
  <span style=color:#6272a4># }</span>
  <span style=color:#bd93f9>86</span><span style=color:#ff79c6>:</span>	fd cf       	rjmp	.-6      	<span style=color:#6272a4># 0x82 &lt;main+0x2&gt;</span>
</code></pre></div><p>Which brings us to the essential question: <strong>is the Arduino framework&rsquo;s implementation right?</strong></p><p>In a sense, <strong>yes</strong>: it translates user-facing Arduino board pin identifiers to hardware pins under the hood, ensures
there are no conflicts with PWM settings, and does update the output register in a correct (atomic) way. <strong>But</strong>, this
is a very costly abstraction (67 instructions + function call compared to one <em>single-cycle</em> instruction). If your code
does some high-frequency bit banging (every few clock cycles), you won&rsquo;t be able to use <code>digitalWrite</code>, which is orders
of magnitude slower, and has side effects (disabling interrupts temporarily).</p><p>Of course, these abstractions are what make Arduino beginner-friendly, but are limited because of their implementation
in C++. A language with more robust compile-time guarantees could reason more efficiently about hardware port usage, and
could also compile to the optimal version &mdash; but <a href=https://github.com/rust-lang/rust/issues/78260 target=_blank rel=noopener>the Rust backend isn&rsquo;t there
yet</a>.</p><p>More details about this assembly comparison are available on <a href=https://vtavernier.github.io/blog-arduino-internals/ target=_blank rel=noopener>this
page</a>. As an extra comparison point, a proof of concept for a
template-based hardware abstraction is included, which compiles to the same optimal assembly as raw AVR code. Please
note that the Arduino version also has timer interrupts for maintaining a clock, which explains most of the program size
difference &mdash; outside of the actual <code>digialWrite</code> calls.</p><p>Personally, I think these limitations should <em>at least</em> be mentioned in the reference documentation. This wouldn&rsquo;t
overload beginners browsing the function reference for the first time, as long as it&rsquo;s hidden in an expandable &ldquo;For
advanced users&rdquo; section. This function <span class=tooltip title="Does this call for a part 2 ðŸ¤”?">isn&rsquo;t the only one
with caveats</span>, and it is likely that large projects using the Arduino platform will encounter more of those &ndash;
undocumented &ndash; limitations and performance/readability trade-offs.</p><h2 id=nrfmbed-based-boards>nrf/Mbed based boards
<a class=heading-link href=#nrfmbed-based-boards><i class="fa fa-link" aria-hidden=true></i></a></h2><h1 id=discussion-pros-and-cons-of-the-arduino-ecosystem>Discussion: pros and cons of the Arduino ecosystem
<a class=heading-link href=#discussion-pros-and-cons-of-the-arduino-ecosystem><i class="fa fa-link" aria-hidden=true></i></a></h1><h1 id=case-study-pwm-dimming-the-arduino-33-bles-rgb-led>Case study: PWM dimming the Arduino 33 BLE&rsquo;s RGB LED
<a class=heading-link href=#case-study-pwm-dimming-the-arduino-33-bles-rgb-led><i class="fa fa-link" aria-hidden=true></i></a></h1><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h1><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>See &ldquo;Syntax&rdquo; and &ldquo;Parameters&rdquo; in
<a href=https://www.arduino.cc/reference/en/language/functions/digital-io/digitalwrite/>https://www.arduino.cc/reference/en/language/functions/digital-io/digitalwrite/</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Using this <a href=https://en.cppreference.com/w/cpp/language/implicit_conversion target=_blank rel=noopener>digest version</a> of the C++
standard for implicit conversions, try predicting what passing an <code>int</code> to a function that expects a <code>byte</code>
(Arduino-specific definition). Bonus points if you can describe what happens on overflow on the various architectures
this code could be run on. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><code>int</code>, <code>char</code>, <code>float</code> and other built-in data-types are C++ built-ins, supported directly by the
target platform and are basically free to create. This isn&rsquo;t the case of the <code>String</code> type, which allocates memory, an
expensive and error-prone operation (running out of heap space overwrites your program&rsquo;s stack &mdash; a &ldquo;technicality&rdquo;
not mentioned in the documentation). <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Creating a project with <code>pio init --ide vim</code> will create the necessary files for the <code>ccls</code>
language server to provide completion and go-to definition for Arduino code. This what I mainly used for this work. <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>On AVR, setting a bit in an output register is an atomic operation (<code>sbi</code> instruction). However,
<code>*port |= mask</code> is a <em>read-modify-write</em> operation since <code>mask</code> may set more than one bit and/or not be a constant. By
being 3 instructions long, there is a chance an interruption could happen between the <em>read</em> and <em>write</em>, and break
the code. Thus, a critical section is required, which equates to temporarily disabling interrupt handling. <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>PlatformIO uses <code>-flto -Os</code> as the default optimization level, but changing those
settings didn&rsquo;t influence the result significantly. <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer><script src=https://utteranc.es/client.js repo=vtavernier/vtavernier.github.io issue-term=pathname label=comments theme=github-dark crossorigin=anonymous async></script></footer></article></section></div><footer class=footer><section class=container><p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>Â©
2019 -
2021
Vincent Tavernier
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.f92783b4545b68f3523e5d6ad91d93f76818f9d0db2ffa13bda31b6119cde62b.js integrity="sha256-+SeDtFRbaPNSPl1q2R2T92gY+dDbL/oTvaMbYRnN5is="></script><script src=/main.js></script><script data-goatcounter=https://vtavernier.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>