<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Vincent Tavernier"><meta name=description content="Git is a helpful tool when it's actually part of your workflow instead of fighting against it. Learn how to use Git to make it this way!"><meta name=keywords content="blog,developer,personal,research,graphics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git is your friend, not your enemy — Part 1"><meta name=twitter:description content="Git is a helpful tool when it's actually part of your workflow instead of fighting against it. Learn how to use Git to make it this way!"><meta property="og:title" content="Git is your friend, not your enemy — Part 1"><meta property="og:description" content="Git is a helpful tool when it's actually part of your workflow instead of fighting against it. Learn how to use Git to make it this way!"><meta property="og:type" content="article"><meta property="og:url" content="https://vtavernier.github.io/posts/git-is-your-friend-part-1/"><meta property="article:published_time" content="2021-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-11T00:00:00+00:00"><meta property="og:see_also" content="https://vtavernier.github.io/posts/git-is-your-friend-part-3/"><meta property="og:see_also" content="https://vtavernier.github.io/posts/git-is-your-friend-part-2/"><title>Git is your friend, not your enemy — Part 1 · The Tavern</title><link rel=canonical href=https://vtavernier.github.io/posts/git-is-your-friend-part-1/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c99932527e4ee59cd8aeb0f42c7aa4dd03a68a027a5cd24af1da34f9e9867fab.css integrity="sha256-yZkyUn5O5ZzYrrD0LHqk3QOmigJ6XNJK8do0+emGf6s=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.876b132a2ef3947e5bdc3c8dbeda49fc71bd5a4abbd4ddfbc92e8112aebfebe3.css integrity="sha256-h2sTKi7zlH5b3DyNvtpJ/HG9Wkq71N37yS6BEq6/6+M=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/main.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.2/twemoji.min.js integrity=sha384-wyB/MspSJ/r2bT2kCj44qtsYRYlpzO2oAPhRj5myrWD63dt6qWv4x8AZe7Fl3K3b crossorigin=anonymous></script><meta name=generator content="Hugo 0.80.0"></head><body class="preload-transitions colorscheme-dark" onload=twemoji.parse(document.body);><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>The Tavern</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/research/>Research</a></li><li class=navigation-item><a class=navigation-link href=/about/>About me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://vtavernier.github.io/posts/git-is-your-friend-part-1/>Git is your friend, not your enemy — Part 1</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2021-01-11T00:00:00Z>January 11, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>17-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><span class=tag><a href=/tags/tutorial/>tutorial</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/git/>git</a></span></div></div></header><div><blockquote><p>This post is the first part of a tutorial series on how to use Git to its full potential, based on my personal
experience and online resources. Although this tutorial will cover some basic parts of using Git, this tutorial is not
adapted if you have no experience at all. The first few chapters of the <a href=https://git-scm.com/book/en/v2 target=_blank rel=noopener>Pro Git book</a>
are a good place to start.</p></blockquote><p>A common trend among inexperienced Git users is to think of Git as a burden that they need to carry along while also
doing the rest of their work. This is especially true as they have not been introduced to the more powerful features of
Git. Thus, Git is just a convoluted way of keeping a version history. Indeed, this is what a typical file editing
session looks like if you&rsquo;re just starting to use Git:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ emacs file.txt

$ git add file.txt
<span style=color:#6272a4># Why do we have to &#34;add&#34; the file again?</span>

<span style=color:#6272a4># Then this?</span>
$ git commit
<span style=color:#6272a4># Now vim is open, great! How do we exit it again?</span>

<span style=color:#6272a4># Try to send the changes</span>
$ git push
To git@github.com:example-org/example.git
 ! <span style=color:#ff79c6>[</span>rejected<span style=color:#ff79c6>]</span>        master -&gt; master <span style=color:#ff79c6>(</span>fetch first<span style=color:#ff79c6>)</span>
error: failed to push some refs to <span style=color:#f1fa8c>&#39;git@github.com:example-org/example.git&#39;</span>
hint: Updates were rejected because the remote contains work that you <span style=color:#ff79c6>do</span>
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: <span style=color:#ff79c6>(</span>e.g., <span style=color:#f1fa8c>&#39;git pull ...&#39;</span><span style=color:#ff79c6>)</span> before pushing again.
hint: See the <span style=color:#f1fa8c>&#39;Note about fast-forwards&#39;</span> in <span style=color:#f1fa8c>&#39;git push --help&#39;</span> <span style=color:#ff79c6>for</span> details.

<span style=color:#6272a4># Ok the tutorial said to use git pull when this happens</span>
$ git pull

<span style=color:#6272a4># Great, now vim opened again... but then</span>
$ git push

<span style=color:#6272a4># All good now!</span>
</code></pre></div><p>And honestly, no one would use Git if it was this hard every time you make a single change inside a file. Especially if
the only thing this enables is &ldquo;you can now use <code>git checkout</code> to manually copy and paste previous versions of your
file, provided you know when the changes happened&rdquo;.</p><p>But 87.2% of developers use Git (<a href=https://insights.stackoverflow.com/survey/2018#work-_-version-control target=_blank rel=noopener>Stack Overflow Developer Survey
2018</a>) for many very valid reasons, so let&rsquo;s
debunk some myths about Git and start using its more powerful features!</p><h1 id=first-properly-configure-git>First: properly configure Git
<a class=heading-link href=#first-properly-configure-git><i class="fa fa-link" aria-hidden=true></i></a></h1><p>The behavior of most Git commands is controlled by <em>Git configuration files</em>. The defaults are set at the system level,
and are then overridden by the user-level file, <code>~/.gitconfig</code>. Here is a typical <code>~/.gitconfig</code> file to get started:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#ff79c6>[user]</span>
	<span style=color:#6272a4># Your full name</span>
	<span style=color:#50fa7b>name</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>Bob Johnson
</span><span style=color:#f1fa8c>	# Your email
</span><span style=color:#f1fa8c>	email = bob.johnson@example.com</span>

<span style=color:#ff79c6>[core]</span>
	<span style=color:#6272a4># The editor git uses for commit messages</span>
	<span style=color:#50fa7b>editor</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>$EDITOR
</span><span style=color:#f1fa8c>	# Or pick any of those:
</span><span style=color:#f1fa8c>	#editor = vim
</span><span style=color:#f1fa8c>	#editor = emacs
</span><span style=color:#f1fa8c>	#editor = subl -n -w
</span><span style=color:#f1fa8c>	#editor = code --wait
</span><span style=color:#f1fa8c>	#editor = atom --wait
</span><span style=color:#f1fa8c>	# etc...</span>
</code></pre></div><p>This sets up your user information as well as your editor preferences. This is all that&rsquo;s needed for now!</p><h1 id=git-isnt-just-a-backup-solution>Git isn&rsquo;t just a backup solution
<a class=heading-link href=#git-isnt-just-a-backup-solution><i class="fa fa-link" aria-hidden=true></i></a></h1><p>Using Git in a project enables contributors to check out previous versions of a given file, or see when it was changed,
for example using the <code>git log</code> command:</p><div class="highlight highlight-manual"><pre><code>$ <span style=font-weight:700;color:#fff>git log --oneline -- CMakeLists.txt</span>
<span style=color:olive>2e2878c</span> Fix dllimport usage
<span style=color:olive>471f7eb</span> Add WebGL support
<span style=color:olive>1d9a8de</span> Fix CMP0077 warnings
<span style=color:olive>2388a7b</span> Add option to disable library types
<span style=color:olive>15fcbe8</span> Fix CMake errors
<span style=color:gray>[etc...]</span></code></pre></div><p>When using <code>--oneline</code>, the first column is the <em>commit hash</em> (or <em>commit SHA</em>) which uniquely identifies what the <code>git commit</code> command added to the repository when it was issued. You can check out how a file looked for a given commit, and
then restore it to its last known state:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ git checkout 1d9a8de -- CMakeLists.txt
$ git checkout HEAD -- CMakeLists.txt
</code></pre></div><p>However, a <em>commit</em> is <strong>not</strong> a version of a file. It is actually a set of changes (a patch) associated with some metadata
(author and committer information, date, and commit message). This is what the <code>git show</code> command allows you to inspect:</p><div class="highlight highlight-manual"><pre><code>$ <span style=font-weight:700;color:#fff>git show 1d9a8de</span>
<span style=color:olive>commit 1d9a8decc4dd7ee42689149dbd763103075f8422</span>
Author: Vincent Tavernier &lt;v.tavernier@pm.me&gt;
Date:   Fri Aug 23 16:25:14 2019 +0200

    Fix CMP0077 warnings

<span style=font-weight:700>diff --git a/CMakeLists.txt b/CMakeLists.txt</span>
<span style=font-weight:700>index e304257..e6b21a5 100644</span>
<span style=font-weight:700>--- a/CMakeLists.txt</span>
<span style=font-weight:700>+++ b/CMakeLists.txt</span>
<span style=color:teal>@@ -49,8 +49,8 @@</span> message(STATUS &quot;shadertoy v${ST_VERSION_FULL} (${SHADERTOY_VERSION_STANDALONE})&quot;
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
 # Use bundled spdlog
<span style=color:red>-set(SPDLOG_BUILD_EXAMPLES OFF)</span>
<span style=color:red>-set(SPDLOG_BUILD_TESTING OFF)</span>
<span style=color:green>+</span><span style=color:green>set(SPDLOG_BUILD_EXAMPLES OFF CACHE BOOL &quot;&quot; FORCE)</span>
<span style=color:green>+</span><span style=color:green>set(SPDLOG_BUILD_TESTING OFF CACHE BOOL &quot;&quot; FORCE)</span>
 set(SPDLOG_DIR ${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/spdlog)
 add_subdirectory(${SPDLOG_DIR} EXCLUDE_FROM_ALL)
 </code></pre></div><p>Each commit also references one (or more in case of a merge) parent commits, which is how the <em>history</em> of a repository
is constructed. Here is an example from the <code>git merge</code> reference manual. <em>A</em> to <em>H</em> refer to commits, <em>topic</em> and
<em>master</em> are branch names. Time evolves from left to right in these graphs, with more recent commits at the right.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>       A---B---C topic
      /         \
 D---E---F---G---H master
</code></pre></div><p>Thus, by thinking of commits as sets of changes instead of versions we can view the history of a repository as a log of
what was changed over time, instead of just a series of snapshots taken at random times. Which brings us to the next
question.</p><h1 id=what-makes-a-good-commit>What makes a good commit?
<a class=heading-link href=#what-makes-a-good-commit><i class="fa fa-link" aria-hidden=true></i></a></h1><p>Previous users of SVN have probably noticed when migrating to Git that committing requires setting a non-empty message
to accompany the change set. However, trying to get around it by just using &ldquo;<code>.</code>&rdquo; or any other non-descriptive message
is probably the worst thing you can do:</p><ul><li>This will render the output of <code>git log</code> completely useless</li><li>You won&rsquo;t have a way of differentiating what each commit changes</li><li>Even worse, if you collaborate with other people on the same repository, they will have to inspect every single change
in every commit to discover what you changed.</li></ul><p>All of this adds up to a lot of wasted time for each collaborator, present and future.</p><p>I instead like to use the time I&rsquo;m spending preparing a commit to reflect on what the commit actually brings to the
project. This makes committing part of my workflow instead of a chore. The key idea behind it is if you changed
something in a project, there is a reason behind it. This reason should be the subject line of your commit message. Here
are a few examples:</p><blockquote><ul><li>Fix window resizing bug</li><li>Add support for non-linear transforms</li><li>Refactor thread pool module</li></ul></blockquote><h2 id=how-to-include-changes-in-a-commit>How to include changes in a commit?
<a class=heading-link href=#how-to-include-changes-in-a-commit><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In the ideal workflow, you work on a single feature/fix at any given time, thus you can add changed files with <code>git add</code>
and commit the result, which will be focused on what you are currently working on only.</p><blockquote><p>But what if you changed multiple things at once and you have multiple reasons for a commit?</p></blockquote><p>Indeed, you might have forgotten to commit regularly, you got carried away developing new features, fixing bugs, etc.
But you should still make <em><strong>individual</strong></em> commits for each of those reasons. Commits are cheap, and by describing each
change you made individually you can create a well-formatted log of changes made to the project for yourself and your
collaborators.</p><p>One way to do that is to use the <code>-p</code> option of <code>git add</code>. This makes <code>git add</code> enter <em>interactive mode</em> where you can
choose to stage (i.e. include in your next commit) each individual change or not. Here is an example of an interactive
staging session using <code>git add -p</code>:</p><div class="highlight highlight-manual"><pre><code>$ <span style=font-weight:700;color:#fff>git add -p</span>
<span style=font-weight:700>diff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt</span>
<span style=font-weight:700>index 84768a1..d259c12 100644</span>
<span style=font-weight:700>--- a/examples/CMakeLists.txt</span>
<span style=font-weight:700>+++ b/examples/CMakeLists.txt</span>
<span style=color:teal>@@ -2,6 +2,8 @@</span> cmake_minimum_required(VERSION 3.10)
 
 project(libshadertoy-examples)
 
<span style=color:green>+</span><span style=color:green>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</span>
<span style=color:green>+</span>
 # Directories
 set(INCLUDE_ROOT ${CMAKE_CURRENT_SOURCE_DIR})
 set(SRC_ROOT ${CMAKE_CURRENT_SOURCE_DIR})
<span style=font-weight:700;color:#66f>Stage this hunk [y,n,q,a,d,e,?]? </span>n

<span style=font-weight:700>diff --git a/examples/web-gradient/CMakeLists.txt b/examples/web-gradient/CMakeLists.txt</span>
<span style=font-weight:700>index eaf57f2..e65928d 100644</span>
<span style=font-weight:700>--- a/examples/web-gradient/CMakeLists.txt</span>
<span style=font-weight:700>+++ b/examples/web-gradient/CMakeLists.txt</span>
<span style=color:teal>@@ -11,6 +11,8 @@</span> target_link_options(example_web_gradient PRIVATE
 	&quot;SHELL:-s EXIT_RUNTIME=1&quot;
 	&quot;SHELL:-s DISABLE_EXCEPTION_CATCHING=0&quot;
 	&quot;SHELL:-s USE_GLFW=3&quot;
<span style=color:green>+</span>	<span style=color:green>&quot;SHELL:-s EXPORTED_FUNCTIONS='[\&quot;_main\&quot;, \&quot;_reset\&quot;, \&quot;_load_source\&quot;, \&quot;_get_source\&quot;]'&quot;</span>
<span style=color:green>+</span>	<span style=color:green>&quot;SHELL:-s EXTRA_EXPORTED_RUNTIME_METHODS='[\&quot;cwrap\&quot;]'&quot;</span>
 	&quot;SHELL:--embed-file ${CMAKE_CURRENT_SOURCE_DIR}/../gradient.glsl@gradient.glsl&quot;)
 
 # C++17
<span style=font-weight:700;color:#66f>Stage this hunk [y,n,q,a,d,e,?]? </span>y

<span style=font-weight:700>diff --git a/examples/web-gradient/main.cpp b/examples/web-gradient/main.cpp</span>
<span style=font-weight:700>index 85dca53..11c3e1c 100644</span>
<span style=font-weight:700>--- a/examples/web-gradient/main.cpp</span>
<span style=font-weight:700>+++ b/examples/web-gradient/main.cpp</span>
<span style=color:teal>@@ -2,10 +2,14 @@</span>
 
 #include &lt;shadertoy.hpp&gt;
 #include &lt;shadertoy/backends/webgl.hpp&gt;
<span style=color:green>+</span><span style=color:green>#include &lt;shadertoy/utils/log.hpp&gt;</span>
 
 #include &lt;GLFW/glfw3.h&gt;
 #include &lt;emscripten.h&gt;
 
<span style=color:green>+</span><span style=color:green>#include &lt;fstream&gt;</span>
<span style=color:green>+</span><span style=color:green>#include &lt;streambuf&gt;</span>
<span style=color:green>+</span>
 struct ctx
 {
 	shadertoy::render_context context;
<span style=font-weight:700;color:#66f>Stage this hunk [y,n,q,a,d,j,J,g,/,s,e,?]? </span>y
<span style=color:teal>@@ -14,7 +18,9 @@</span> struct ctx
 	GLFWwindow *window;
 	int frameCount;
 	float t = 0.;
<span style=color:green>+</span>	<span style=color:green>float t_offset = 0.;</span>
 	std::unique_ptr&lt;shadertoy::backends::gx::backend&gt; backend;
<span style=color:green>+</span>	<span style=color:green>std::string shader_source;</span>
 
 	ctx(GLFWwindow *window) : window(window), frameCount(0), t(0.)
 	{
<span style=font-weight:700;color:#66f>Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? </span>q</code></pre></div><p>In interactive staging mode, you can get a reminder of available commands by typing <code>h</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>y - stage this hunk
n - do not stage this hunk
q - quit; do not stage this hunk or any of the remaining ones
a - stage this hunk and all later hunks in the file
d - do not stage this hunk or any of the later hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
</code></pre></div><p>A <em>hunk</em> in Git terminology is a block of changes. You can decide to include it (<code>y</code>) or not (<code>n</code>) in your next commit.
If it is made up of several changes (such as the 3rd and 4th hunks in the previous example), you can split it into
smaller hunks using <code>s</code> and then decide on the fate of individual changes. <code>a</code> and <code>d</code> are the file-level equivalent of
<code>y</code> and <code>n</code> if you know all hunks in the current file should be staged or not. <code>e</code> is an advanced feature that allows
you to stage a different change to what Git detected, but you should first be familiar with
<a href=https://en.wikipedia.org/wiki/Patch_%28Unix%29 target=_blank rel=noopener>patch files</a> in order to use it.</p><p>If you staged a hunk by mistake, don&rsquo;t worry: <code>git reset</code>, the command to un-stage changes also supports the <code>-p</code>
option. Note that the logic is reversed in that case (<code>y</code> will <em>reset</em> the hunk being shown, thus un-staging it, while
<code>n</code> does nothing and leaves it staged). <code>git checkout</code> also supports <code>-p</code> in case you need it.</p><h2 id=writing-a-good-commit-message>Writing a good commit message
<a class=heading-link href=#writing-a-good-commit-message><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Once you selected all changes you want to include in your commit, you can commit them to the repository with <code>git commit</code>. Commit messages should be made of:</p><ol><li>A subject line: a short (&lt;50 characters) summary of what the commit changes. This is the reason mentioned earlier in
this article.</li><li>A blank line to end the subject line.</li><li>An extended description of the commit (optional): if your commit is non-trivial, include a short write-up of your
thought process through the making of that change. This will serve as future reference for you and your
collaborators, and <em>bonus</em> if you&rsquo;re using GitHub, this will automatically be used as the description of the pull
request if you are using those in your workflow.</li></ol><p>There are a lot of <a href=https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html target=_blank rel=noopener>resources</a> and conventions
available on how to write good commit messages, some of them even using <a href=https://gitmoji.carloscuesta.me/ target=_blank rel=noopener>emoji</a>. What
is important is to be consistent: pick a way to write your commit messages, and stick to it <em><strong>every</strong></em> time you commit.</p><h1 id=sharing-your-work-with-others>Sharing your work with others
<a class=heading-link href=#sharing-your-work-with-others><i class="fa fa-link" aria-hidden=true></i></a></h1><p>Chances are that you are using Git to work with other people on the same project. When starting out with Git this is
usually the hard part, but it doesn&rsquo;t have to be. Let&rsquo;s see how Git handles those situations.</p><h2 id=repositories-and-remotes>Repositories and remotes
<a class=heading-link href=#repositories-and-remotes><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Everyone working on a project using Git has a full copy of the repository. This means the current state of the branches,
as well as their entire history. Thus, most git commands work on locally stored state and don&rsquo;t need network access;
this makes the Git workflow fast and resilient to network failures.</p><p>When synchronizing your changes with a server (a GitHub, GitLab, Bitbucket, etc. repository), Git tries to assemble
together the changes made on both sides in a deterministic way. In Git terminology, the &ldquo;<em>other</em>&rdquo; repository you&rsquo;re
synchronizing with is called a <em>remote</em>. When you use <code>git clone [url]</code>, the remote at the address <code>url</code> will be
called <code>origin</code>.</p><p>You can list branches using the <code>git branch -a</code> command:</p><div class="highlight highlight-manual"><pre><code>$ <span style=font-weight:700;color:#fff>git branch -a</span>
  develop
* <span style=color:green>master</span>
  <span style=color:red>remotes/origin/HEAD</span> -&gt; origin/master
  <span style=color:red>remotes/origin/develop</span>
  <span style=color:red>remotes/origin/gh-pages</span>
  <span style=color:red>remotes/origin/master</span></code></pre></div><p>A few things are worth noting:</p><ul><li>There are two local branches (they have no <code>[remote]/</code> prefix in their name): <code>master</code> and <code>develop</code>. <code>master</code> is the
current branch (denoted by an asterisk).</li><li>The <code>origin</code> remote has three branches: <code>master</code>, <code>develop</code> and <code>gh-pages</code>.</li><li>The default branch of the remote repository is <code>master</code>: this is what <code>origin/HEAD</code> points to, and is checked out when
you clone the repository initially<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul><p>Since all this information is stored locally, the remote branches represent the last known state of the remote
repository. Running the <code>git status</code>, <code>git branch</code> or even <code>git checkout origin/master</code> commands will <strong>not</strong> try to
read the remote repository. You have to use the <code>git fetch</code> command if you want to update your local copy of the
repository to the current state of the remote.</p><p>Furthermore, the changes you make to a branch happen to the local copy of the branch you are currently on (the one
pointed to by <code>HEAD</code>). Thus, if you want to compare your branch with the current state of the remote branch of the same
name, you can use the following command:</p><div class="highlight highlight-manual"><pre><code>$ <span style=font-weight:700;color:#fff>git diff master..origin/master</span>
<span style=font-weight:700>diff --git a/.travis.yml b/.travis.yml</span>
<span style=font-weight:700>index d8cf3e8..00a66ce 100644</span>
<span style=font-weight:700>--- a/.travis.yml</span>
<span style=font-weight:700>+++ b/.travis.yml</span>
<span style=color:teal>@@ -58,12 +58,7 @@</span> script: |
         # Docker image parameters
         BUILD_IMAGE=${PACKAGE_NAME}/${OS_DIST}_${OS_VERSION}
         # TODO: i386
<span style=color:red>-        docker run --mount type=bind,source=$(pwd),target=/build --rm $BUILD_IMAGE \</span>
<span style=color:red>-          make \</span>
<span style=color:red>-          BINTRAY_API_KEY=$BINTRAY_API_KEY \</span>
<span style=color:red>-          BINTRAY_ORG=$BINTRAY_ORG \</span>
<span style=color:red>-          CI_COMMIT_REF_NAME=$TRAVIS_TAG \</span>
<span style=color:red>-          gl</span>
<span style=color:green>+</span><span style=color:green>        docker run --mount type=bind,source=$(pwd),target=/build --rm $BUILD_IMAGE make CI_COMMIT_REF_NAME=$TRAVIS_TAG gl</span>
       fi
     )
   elif [ $TRAVIS_OS_NAME = windows ]; then
<span style=color:teal>@@ -75,7 +70,6 @@</span> script: |
 after_success: |
   [ $TRAVIS_PULL_REQUEST = false ] &amp;&amp;
   [ $TRAVIS_OS_NAME = linux ] &amp;&amp;
<span style=color:red>-  [[ $TRAVIS_BRANCH =~ &quot;^master|develop$&quot; ]] &amp;&amp;</span>
   [ $OS_TYPE = deb ] &amp;&amp;
   [ $OS_DIST = debian ] &amp;&amp;
   [ $OS_VERSION = buster ] &amp;&amp;
<span style=color:gray>[etc...]</span></code></pre></div><p>Note that this is how the <code>git status</code> determines the state of your branch relative to the remote branch.</p><h2 id=sending-your-work-to-a-remote>Sending your work to a remote
<a class=heading-link href=#sending-your-work-to-a-remote><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Once your local copy of the remote branches is up-to-date (<code>git fetch origin</code> for the <code>origin</code> remote) and you decide to
send your (committed) work, you will encounter one of these cases:</p><ul><li><p>No one worked on the remote copy of the branch you are currently working on. Thus, you only added commits to the <em>end</em>
of the history for that branch. Graphically, this can be represented as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>       origin/master
      /
 D---E---F---G---H master
</code></pre></div><p>Sending your changes to the remote is trivial in this case: since the history is linear it is just a matter of sending
the commit data to the server, and updating where the remote <code>master</code> branch points to. This is referred to as a
<code>fast-forward</code> merge in the Git documentation. Think of it as the <code>origin/master</code> label just skipping through commits
to its current location:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>        &gt; &gt; &gt; &gt; &gt;  origin/master
      /           /
 D---E---F---G---H master
</code></pre></div><p>This is the <em>happy path</em>, just use <code>git push</code> and it will work as expected.</p></li><li><p>Someone else (or yourself on a different machine) worked on the same branch. This will be noted by this kind of output
in <code>git status</code> (emphasis mine):</p><div class="highlight highlight-manual"><pre><code>On branch develop
<span style=font-weight:700>Your branch and 'origin/develop' have diverged,
and have 1 and 1 different commits each, respectively.</span>
  (use "git pull" to merge the remote branch into yours)
[...]</code></pre></div><p>Again, represented as graph, the situation is as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>        A---B---C origin/master
       /
  D---E---F---G---H master
</code></pre></div><p>Which brings us to the last part of this tutorial: strategies for merging your work and remote changes.</p></li></ul><h2 id=merging-remote-changes----how-to-git-pull>Merging remote changes &ndash; How to <code>git pull</code>
<a class=heading-link href=#merging-remote-changes----how-to-git-pull><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The situation we just witnessed requires &ldquo;manual&rdquo; action. There is no way for Git to decide which strategy to choose to
solve this problem since mind-reading has not been implemented into any known Git clients yet. We have two options to
solve this conflict:</p><ul><li>Integrate the remote&rsquo;s changes into our own, and push the result: this is the default behavior of Git you have
probably encountered already. We&rsquo;ll refer to this strategy as a <em>merge pull</em><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. This strategy is
suitable when you are responsible for integrating the remote changes into your work before sharing it.</li><li>Apply our local changes onto the new state of the remote: this is an alternative to the first behavior which can be
set as the default, or invoked through <code>git pull --rebase</code>. We&rsquo;ll refer to this strategy as a <em>rebase
pull</em><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. This strategy requires you to modify your (already-made) changes to be able to integrate
with the existing remote changes, before sharing it.</li></ul><p>You might encounter online posts or people advising you to always stick to one of the two approaches. This is heavily
misguided advice however, since each strategy has its pros and cons, and you should always evaluate which one is
appropriate depending on the context. Let us review these two approaches for the above case.</p><h3 id=merge-pull><em>Merge pull</em>
<a class=heading-link href=#merge-pull><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Without <code>--rebase</code>, <code>git pull</code> is equivalent to <code>git fetch && git merge origin/master</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. This
will result in the following situation:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>                  origin/master
                 /
        A---B---C---.
       /             \
  D---E---F---G---H---M master
</code></pre></div><ul><li>A <em>merge commit</em> was created: this is the commit <em>M</em> which was added to the local <code>master</code> branch. Note that it has
two parents, <em>C</em> and <em>H</em>. Aside from indicating we are combining two branches together, eventual merge conflicts would
be solved and committed as part of this commit.</li><li>The <code>origin/master</code> branch is still on commit <em>C</em>. This will be updated once we push to the <code>origin</code> remote with the
<code>git push</code> command.</li></ul><p>This merge operation solves the problem encountered by <code>git push</code>: there is now a fast-forward path for the
<code>origin/master</code> branch:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>                 / &gt; &gt; &gt; origin/master
        A---B---C---.   /
       /             \ /
  D---E---F---G---H---M master
</code></pre></div><p>The main drawback of this kind of <code>git pull</code> is that it results in a non-linear history. If it makes sense to have an
explicit merge commit, this is the recommended approach. However a <em>rebase pull</em> is more suited for merging unrelated, non-conflicting work and obtain a linear history.</p><h3 id=rebase-pull><em>Rebase pull</em>
<a class=heading-link href=#rebase-pull><i class="fa fa-link" aria-hidden=true></i></a></h3><p>With <code>--rebase</code>, <code>git pull</code> is equivalent to <code>git fetch && git rebase origin/master</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. This will
result in the following situation:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>                  origin/master
                 /
        A---B---C---F&#39;---G&#39;---H&#39; master
       /
  D---E---F---G---H
</code></pre></div><ul><li>Three commits were created: <em>F'</em>, <em>G'</em> and <em>H'</em>: these commits correspond to the <em>F</em>, <em>G</em> and <em>H</em> commits (our local
work), but <em>rebased</em> onto the <code>origin/master</code> branch. The resulting <code>master</code> branch looks as if we committed our work
after <em>A</em>, <em>B</em> and <em>C</em> were added to the repository.</li><li>The <code>origin/master</code> branch is still on commit <em>C</em>. This will be updated once we push to the <code>origin</code> remote with the
<code>git push</code> command.</li></ul><p>This rebase operation also solves the problem encountered by <code>git push</code>: there is now a fast-forward path for the
<code>origin/master</code> branch:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>                  &gt; &gt; &gt; &gt; &gt; &gt; &gt; origin/master
                 /             /
        A---B---C---F&#39;---G&#39;---H&#39; master
       /
  D---E---F---G---H
</code></pre></div><p>Note that contrarily to the <em>merge pull</em>, the history is linear and does not keep a trace of a merge operation
happening. If we remove the old <code>master</code> branch state from the graph, we obtain one single branch in the history:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>                              origin/master
                             /
  D---A---B---C---F&#39;---G&#39;---H&#39; master
</code></pre></div><p>This makes the log less noisy and thus much more readable. This doesn&rsquo;t make the <em>rebase pull</em> the magical solution:</p><ul><li>Rebasing might introduce merge conflicts to be resolved at every single commit being rebased (3 in our case).</li><li>Rebasing changes the history (the commit SHA depends on the parent commit, which changes with a rebase), so if you
already published the <em>F</em>, <em>G</em> and <em>H</em> commits, you should <em><strong>absolutely not</strong></em> rebase commits.</li></ul><h3 id=git-pull-conclusion><code>git pull</code> conclusion
<a class=heading-link href=#git-pull-conclusion><i class="fa fa-link" aria-hidden=true></i></a></h3><p>I will leave whether or not to add <code>--rebase</code> to your <code>git pull</code> commands to you, since they depend on your workflow.
Personally, I always use <code>git pull --rebase</code> as long as I am working with local branch changes, and regular <em>merge
pulls</em> otherwise. You can enable <code>git pull --rebase</code> by default globally: <code>git config --global pull.rebase true</code>, and
make <em>merge pulls</em> instead with <code>git pull --no-rebase</code>.</p><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h1><p>In this first part, we reviewed the basics of writing good commits to keep the history useful, and how to properly merge
those changes with the remote repository, and how this relates to a standard version-controlled workflow.</p><p>In the next part we will look into more advanced techniques such as <em>interactive rebasing</em> as a way to cleanup a messy
(local) history, and using a merge tool to solve merge conflicts.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Following the Black Lives Matter protests of 2020, many companies and individuals started
changing the default branch name of their Git repositories to other names. Look out for those in case your tools
complain about a missing master branch. One way to check for this is to use the <code>git remote show [remote]</code> command
and look for <code>HEAD branch</code> in its output. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>These terms are not used in the official documentation, but we use them here for simplicity. The
man page for <code>git pull</code> explains the operation of these in much more detail if you need it. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>We&rsquo;re pushing to the <code>master</code> branch of the <code>origin</code> repository in this case. Remember to
adapt this to your repository when following this tutorial. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer><section class=see-also><h3 id=see-also-in-git-is-your-friend-not-your-enemy>See also in Git is your friend, not your enemy
<a class=heading-link href=#see-also-in-git-is-your-friend-not-your-enemy><i class="fa fa-link" aria-hidden=true></i></a></h3><nav><ul><li><a href=/posts/git-is-your-friend-part-3/>Git is your friend, not your enemy — Part 3</a></li><li><a href=/posts/git-is-your-friend-part-2/>Git is your friend, not your enemy — Part 2</a></li></ul></nav></section><script src=https://utteranc.es/client.js repo=vtavernier/vtavernier.github.io issue-term=pathname label=comments theme=github-dark crossorigin=anonymous async></script></footer></article></section></div><footer class=footer><section class=container><p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>©
2019 -
2022
Vincent Tavernier
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/main.js></script><script data-goatcounter=https://vtavernier.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>