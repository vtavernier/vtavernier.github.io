<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Vincent Tavernier"><meta name=description content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL 4.x language, with partial support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support   Why not pick this crate?"><meta name=keywords content="blog,developer,personal,research,graphics"><meta name=twitter:card content="summary"><meta name=twitter:title content="glsl-lang"><meta name=twitter:description content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL 4.x language, with partial support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support   Why not pick this crate?"><meta property="og:title" content="glsl-lang"><meta property="og:description" content="glsl-lang      
glsl-lang is a crate implementing a LALR parser for the GLSL 4.x language, with partial support for preprocessor directives. Its AST and features are modeled after Dimitri Sabadie&rsquo;s glsl crate.
Table of contents     Repository structure glsl-lang vs. glsl crates  Why pick this crate?  It&rsquo;s fast Syntax nodes have location information Re-written GLSL transpiler glsl-lang-quote quoting support   Why not pick this crate?"><meta property="og:type" content="article"><meta property="og:url" content="https://vtavernier.github.io/projects/glsl-lang/"><title>glsl-lang · The Tavern</title><link rel=canonical href=https://vtavernier.github.io/projects/glsl-lang/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.34dfa7b2f5cdeb0f5302b2628f4a7a4bfe88a2431e1397ee4ec605c56ab69701.css integrity="sha256-NN+nsvXN6w9TArJij0p6S/6IokMeE5fuTsYFxWq2lwE=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.d8f89ef09509afb63b9b2595ee174e53cc51ce02a6f6a2179e1621f9389e4340.css integrity="sha256-2Pie8JUJr7Y7myWV7hdOU8xRzgKm9qIXnhYh+TieQ0A=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/main.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.2/twemoji.min.js integrity=sha384-wyB/MspSJ/r2bT2kCj44qtsYRYlpzO2oAPhRj5myrWD63dt6qWv4x8AZe7Fl3K3b crossorigin=anonymous></script><meta name=generator content="Hugo 0.80.0"></head><body class="preload-transitions colorscheme-dark" onload=twemoji.parse(document.body);><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>The Tavern</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/research/>Research</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1><a href=https://github.com/vtavernier/glsl-lang>glsl-lang</a></h1></header><p><a href=https://github.com/vtavernier/glsl-lang/actions target=_blank rel=noopener><img src="https://github.com/vtavernier/glsl-lang/workflows/build/badge.svg?branch=master" alt=Build></a> <a href=https://crates.io/crates/glsl-lang target=_blank rel=noopener><img src=https://img.shields.io/crates/v/glsl-lang alt=Crates.io></a> <a href=https://docs.rs/glsl-lang/ target=_blank rel=noopener><img src=https://img.shields.io/docsrs/glsl-lang alt=docs.rs></a> <a href=https://github.com/vtavernier/glsl-lang/blob/master/LICENSE target=_blank rel=noopener><img src=https://img.shields.io/github/license/vtavernier/glsl-lang alt=License></a></p><p><code>glsl-lang</code> is a crate implementing a LALR parser for the GLSL 4.x language,
with partial support for preprocessor directives. Its AST and features are
modeled after <a href=https://github.com/phaazon/glsl target=_blank rel=noopener>Dimitri Sabadie&rsquo;s <code>glsl</code> crate</a>.</p><h2 id=table-of-contents>Table of contents
<a class=heading-link href=#table-of-contents><i class="fa fa-link" aria-hidden=true></i></a></h2><ul><li><a href=#repository-structure>Repository structure</a></li><li><a href=#glsl-lang-vs-glsl-crates><code>glsl-lang</code> vs. <code>glsl</code> crates</a><ul><li><a href=#why-pick-this-crate>Why pick this crate?</a><ul><li><a href=#its-fast>It&rsquo;s fast</a></li><li><a href=#syntax-nodes-have-location-information>Syntax nodes have location information</a></li><li><a href=#re-written-glsl-transpiler>Re-written GLSL transpiler</a></li><li><a href=#glsl-lang-quote-quoting-support><code>glsl-lang-quote</code> quoting support</a></li></ul></li><li><a href=#why-not-pick-this-crate>Why not pick this crate?</a><ul><li><a href=#stateful-lexer>Stateful lexer</a></li><li><a href=#parser-generation-and-compile-times>Parser generation and compile times</a></li><li><a href=#glsl-lang-quote-state><code>glsl-lang-quote</code> state</a></li><li><a href=#ast-differences>AST differences</a></li><li><a href=#documentation>Documentation</a></li></ul></li></ul></li><li><a href=#limitations>Limitations</a></li><li><a href=#license>License</a></li></ul><h2 id=repository-structure>Repository structure
<a class=heading-link href=#repository-structure><i class="fa fa-link" aria-hidden=true></i></a></h2><table><thead><tr><th>crates.io</th><th>Path</th><th>Description</th></tr></thead><tbody><tr><td><a href=https://crates.io/crates/glsl-lang target=_blank rel=noopener><img src=https://img.shields.io/crates/v/glsl-lang alt=Crates.io></a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang target=_blank rel=noopener><code>lang</code></a></td><td>AST, parser, visitor, transpiler for GLSL language</td></tr><tr><td><a href=https://crates.io/crates/glsl-lang-quote target=_blank rel=noopener><img src=https://img.shields.io/crates/v/glsl-lang-quote alt=Crates.io></a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-quote target=_blank rel=noopener><code>lang-quote</code></a></td><td>proc-macro crate to parse GLSL at compile-time</td></tr><tr><td><a href=https://crates.io/crates/glsl-lang-cli target=_blank rel=noopener><img src=https://img.shields.io/crates/v/glsl-lang-cli alt=Crates.io></a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-cli target=_blank rel=noopener><code>lang-cli</code></a></td><td>simple CLI tool to show GLSL syntax trees</td></tr><tr><td><a href=https://crates.io/crates/lang-util target=_blank rel=noopener><img src=https://img.shields.io/crates/v/lang-util alt=Crates.io></a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-util target=_blank rel=noopener><code>lang-util</code></a></td><td>utilities for implementing syntax trees</td></tr><tr><td><a href=https://crates.io/crates/lang-util-derive target=_blank rel=noopener><img src=https://img.shields.io/crates/v/lang-util-derive alt=Crates.io></a></td><td><a href=https://github.com/vtavernier/glsl-lang/blob/master/lang-util-derive target=_blank rel=noopener><code>lang-util-derive</code></a></td><td>proc-macro crate to implement a syntax tree with span information</td></tr></tbody></table><h2 id=glsl-lang-vs-glsl-crates><code>glsl-lang</code> vs. <code>glsl</code> crates
<a class=heading-link href=#glsl-lang-vs-glsl-crates><i class="fa fa-link" aria-hidden=true></i></a></h2><h3 id=why-pick-this-crate>Why pick this crate?
<a class=heading-link href=#why-pick-this-crate><i class="fa fa-link" aria-hidden=true></i></a></h3><h4 id=its-fast>It&rsquo;s fast
<a class=heading-link href=#its-fast><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Due to using a LALR parser and dedicated tokenizer, it&rsquo;s 500x faster than
<code>glsl</code>:</p><pre><code>$ cargo criterion --bench glsl -- --sample-size 1000
TranslationUnit: void main() { ((((((((1.0f)))))))); }/lalrpop
                        time:   [7.7858 us 7.7945 us 7.8027 us]
TranslationUnit: void main() { ((((((((1.0f)))))))); }/glsl
                        time:   [3.1827 ms 3.1831 ms 3.1836 ms]
</code></pre><h4 id=syntax-nodes-have-location-information>Syntax nodes have location information
<a class=heading-link href=#syntax-nodes-have-location-information><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Most nodes in the AST are wrapped in a special <code>Node</code> type, which holds:</p><ul><li><code>source_id</code>: an <code>usize</code> to identify which parsing pass produced this node</li><li><code>start</code>: the starting offset of the node in the corresponding input</li><li><code>end</code>: the ending offset of the node in the corresponding input</li></ul><h4 id=re-written-glsl-transpiler>Re-written GLSL transpiler
<a class=heading-link href=#re-written-glsl-transpiler><i class="fa fa-link" aria-hidden=true></i></a></h4><p>The GLSL transpiler has been partially rewritten to generate indented code.
It&rsquo;s still a work-in-progress but generates (mostly) readable code.</p><h4 id=glsl-lang-quote-quoting-support><code>glsl-lang-quote</code> quoting support
<a class=heading-link href=#glsl-lang-quote-quoting-support><i class="fa fa-link" aria-hidden=true></i></a></h4><p><code>glsl-lang-quote</code> is the <code>glsl-lang</code> version of <code>glsl-quasiquote</code>. It parses
GLSL at compile-time to generate an AST. However, you can also insert parts
of runtime-generated AST using a quoting syntax. Currently, the following
insertion locations for the <code>#(ident)</code> syntax are supported:</p><ul><li>Identifier</li><li>Expression</li><li>Function name</li></ul><h3 id=why-not-pick-this-crate>Why not pick this crate?
<a class=heading-link href=#why-not-pick-this-crate><i class="fa fa-link" aria-hidden=true></i></a></h3><h4 id=stateful-lexer>Stateful lexer
<a class=heading-link href=#stateful-lexer><i class="fa fa-link" aria-hidden=true></i></a></h4><p>C-based grammar are ambiguous by definition. The main ambiguity being the
inability of the parser to solve conflicts between type names and identifiers
without extra context. Thus, to enable LALR parsing of GLSL, we need to
maintain a list of identifiers that are declared as type names, so the lexer
can properly return <code>IDENT</code> or <code>TYPE_NAME</code> as it is reading the file.</p><p>Depending on your use case, this might prove unwieldy since the parser is not
context-free. Parsing one translation unit followed by another requires
forwarding the type name/identifier disambiguation table to the second pass.</p><h4 id=parser-generation-and-compile-times>Parser generation and compile times
<a class=heading-link href=#parser-generation-and-compile-times><i class="fa fa-link" aria-hidden=true></i></a></h4><p>The GLSL grammar is implemented in
<a href=https://github.com/vtavernier/glsl-lang/blob/master/lang/src/parser.lalrpop target=_blank rel=noopener><code>lang/src/parser.lalrpop</code></a> using
<a href=https://github.com/lalrpop/lalrpop target=_blank rel=noopener>LALRPOP</a>. The default feature set only
allows parsing translation units (the top-level rule in the GLSL grammar),
which results in a 25k lines parser file. If you want to include more parsers
(for example for expressions, statements, etc.) you will need to enable the
respective features (<code>parser-expr</code>, <code>parser-statement</code>, etc.) but this will
slow down the compilation of <code>glsl-lang</code> by a significant amount.</p><p>To alleviate this issue, you can use the <code>Parsable</code> trait: by wrapping a syntax
item in a suitable source, and then matching the resulting AST, we can extract
the result of any rule in the grammar. Currently, this interface panics if the
output AST cannot be matched, so don&rsquo;t use it on unknown input. It&rsquo;s fine for
testing though.</p><h4 id=glsl-lang-quote-state><code>glsl-lang-quote</code> state
<a class=heading-link href=#glsl-lang-quote-state><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Parsing preprocessor directives is currently not supported.</p><h4 id=ast-differences>AST differences
<a class=heading-link href=#ast-differences><i class="fa fa-link" aria-hidden=true></i></a></h4><p>There are some differences in both crate&rsquo;s ASTs, so porting to <code>glsl-lang</code>
would require some changes to your code:</p><ul><li>The <code>Statement/SimpleStatement/CompoundStatement</code> structure was flattened to <code>Statement</code></li><li>The <code>subroutine</code> storage qualifier takes a <code>TypeSpecifier</code> array instead of a <code>TypeName</code> array</li><li><code>FunIdentifier::Identifier</code> was replaced with <code>FunIdentifier::TypeSpecifier</code>:
this reflects the fact that a type specifier as a function identifier is a
constructor, and array specifiers are only allowed in this position.</li><li>Support for the <code>attribute</code> and <code>varying</code> qualifiers was removed</li><li>The <code>NonEmpty</code> wrapper was removed</li><li><code>Declaration::Global</code> was removed since it&rsquo;s parsed as an <code>InitDeclaratorList</code></li></ul><h4 id=documentation>Documentation
<a class=heading-link href=#documentation><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Most items are documented (through <code>#[deny(missing_docs)]</code>) although we are
currently missing some usage examples. These will come soon enough, promise!</p><h2 id=limitations>Limitations
<a class=heading-link href=#limitations><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Aside from the limitations mentioned in the paragraph above:</p><ul><li>Only GLSL 3.x/4.x is supported. GLSL 1.x is not</li><li>As for the <code>glsl</code> crate, preprocessor parsing is mostly handled at the syntax
level, so GLSL sources which are syntactically invalid without actual
preprocessing will fail to parse.</li><li>Currently, no semantic analysis</li></ul><h2 id=license>License
<a class=heading-link href=#license><i class="fa fa-link" aria-hidden=true></i></a></h2><p>This work is licensed under the BSD 3-clause license. Lexer and LALR parser by
Vincent Tavernier <a href=mailto:vince.tavernier@gmail.com>vince.tavernier@gmail.com</a>. Original AST, test suite and
quoting code by Dimitri Sabadie <a href=mailto:dimitri.sabadie@gmail.com>dimitri.sabadie@gmail.com</a>.</p></article></section></div><footer class=footer><section class=container><p>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</p>©
2019 -
2021
Vincent Tavernier
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.a350362441276ec5c1671926420497bb8e52b63ead1d51d3c9bc4342d0039526.js integrity="sha256-o1A2JEEnbsXBZxkmQgSXu45Stj6tHVHTybxDQtADlSY="></script><script src=/main.js></script><script data-goatcounter=https://vtavernier.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>