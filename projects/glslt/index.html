<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=color-scheme content="light dark">
<meta name=author content="Vincent Tavernier">
<meta name=description content="glslt      
glslt is a prototype language for adding template functions to the GLSL language.
Although they are not strictly needed for basic shading operations, they are of particular interest for designing reusable GLSL components which agree on common interfaces, as function pointers (or callbacks) would provide.
Table of contents     Installation Usage  Static template function parameters Lambda template function parameters  Named placeholders   Nested lambda expressions Support for include directives Minifying mode   Features Bindings  Rust Python   Limitations Author  Installation    Check out the releases for pre-compiled binaries for stable versions.">
<meta name=keywords content="blog,developer,personal,research,graphics">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="glslt">
<meta name=twitter:description content="glslt      
glslt is a prototype language for adding template functions to the GLSL language.
Although they are not strictly needed for basic shading operations, they are of particular interest for designing reusable GLSL components which agree on common interfaces, as function pointers (or callbacks) would provide.
Table of contents     Installation Usage  Static template function parameters Lambda template function parameters  Named placeholders   Nested lambda expressions Support for include directives Minifying mode   Features Bindings  Rust Python   Limitations Author  Installation    Check out the releases for pre-compiled binaries for stable versions.">
<meta property="og:title" content="glslt">
<meta property="og:description" content="glslt      
glslt is a prototype language for adding template functions to the GLSL language.
Although they are not strictly needed for basic shading operations, they are of particular interest for designing reusable GLSL components which agree on common interfaces, as function pointers (or callbacks) would provide.
Table of contents     Installation Usage  Static template function parameters Lambda template function parameters  Named placeholders   Nested lambda expressions Support for include directives Minifying mode   Features Bindings  Rust Python   Limitations Author  Installation    Check out the releases for pre-compiled binaries for stable versions.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://vtavernier.github.io/projects/glslt/"><meta property="article:section" content="projects">
<title>The Tavern</title><link rel=canonical href=https://vtavernier.github.io/projects/glslt/>
<link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin>
<link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen>
<link rel=stylesheet href=/css/main.min.eee8b4bae3f8317f1bbbaba644bd5343666fc10948260e11f665c17f082d882c.css integrity="sha256-7ui0uuP4MX8bu6umRL1TQ2ZvwQlIJg4R9mXBfwgtiCw=" crossorigin=anonymous media=screen>
<link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32>
<link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16>
<link rel=apple-touch-icon href=/images/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5>
<meta name=generator content="Hugo 0.93.3">
</head><body class="preload-transitions colorscheme-dark">
<main class=wrapper>
<nav class=navigation>
<section class=container>
<a class=navigation-title href=/>
The Tavern
</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle>
<i class="fa fa-bars fa-fw" aria-hidden=true></i>
</label>
<ul class=navigation-list>
<li class=navigation-item>
<a class=navigation-link href=/posts/>Blog</a>
</li><li class=navigation-item>
<a class=navigation-link href=/projects/>Projects</a>
</li><li class=navigation-item>
<a class=navigation-link href=/research/>Research</a>
</li><li class=navigation-item>
<a class=navigation-link href=/about/>About me</a>
</li></ul></section></nav><div class=content>
<section class="container page">
<article>
<header>
<h1>
<a href=https://github.com/vtavernier/glslt>glslt</a>
</h1></header><p><a href=https://github.com/vtavernier/glslt/actions target=_blank rel=noopener>
<img src="https://github.com/vtavernier/glslt/workflows/Run%20tests/badge.svg?branch=master" alt="Run tests">
</a> <a href=https://github.com/vtavernier/glslt/releases target=_blank rel=noopener>
<img src=https://img.shields.io/github/v/release/vtavernier/glslt alt="GitHub release">
</a> <a href=https://pypi.org/project/glslt/ target=_blank rel=noopener>
<img src=https://img.shields.io/pypi/v/glslt alt=PyPI>
</a> <a href=https://github.com/vtavernier/glslt/blob/master/LICENSE target=_blank rel=noopener>
<img src=https://img.shields.io/github/license/vtavernier/glslt alt=License>
</a></p><p><code>glslt</code> is a prototype language for adding template functions to the GLSL
language.</p><p>Although they are not strictly needed for basic shading operations, they are of
particular interest for designing reusable GLSL components which agree on
common interfaces, as function pointers (or callbacks) would provide.</p><h2 id=table-of-contents>
Table of contents
<a class=heading-link href=#table-of-contents>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><ul>
<li><a href=#installation>Installation</a></li><li><a href=#usage>Usage</a>
<ul>
<li><a href=#static-template-function-parameters>Static template function parameters</a></li><li><a href=#lambda-template-function-parameters>Lambda template function parameters</a>
<ul>
<li><a href=#named-placeholders>Named placeholders</a></li></ul></li><li><a href=#nested-lambda-expressions>Nested lambda expressions</a></li><li><a href=#support-for-include-directives>Support for include directives</a></li><li><a href=#minifying-mode>Minifying mode</a></li></ul></li><li><a href=#features>Features</a></li><li><a href=#bindings>Bindings</a>
<ul>
<li><a href=#rust>Rust</a></li><li><a href=#python>Python</a></li></ul></li><li><a href=#limitations>Limitations</a></li><li><a href=#author>Author</a></li></ul><h2 id=installation>
Installation
<a class=heading-link href=#installation>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><p>Check out the <a href=https://github.com/vtavernier/glslt/releases target=_blank rel=noopener>releases</a> for
pre-compiled binaries for stable versions. Installing the Python module (see
below) also installs the corresponding <code>glsltc</code> binary.</p><p>Alternatively, you may compile <code>glslt</code> from source, assuming you have the
<a href=https://rustup.rs/ target=_blank rel=noopener>Rust</a> compiler installed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># From crates.io</span>
</span></span><span style=display:flex><span>cargo install --force glslt_cli
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># From the repository</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>## Fetch the source</span>
</span></span><span style=display:flex><span>git clone https://github.com/vtavernier/glslt.git
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>cd</span> glslt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>## Run the program directly</span>
</span></span><span style=display:flex><span>cargo run -- test.glsl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>## Or, install the glsltc binary permanently</span>
</span></span><span style=display:flex><span>cargo install --force --path .
</span></span><span style=display:flex><span>glsltc test.glsl
</span></span></code></pre></div><p>To install the Python module for the latest stable version, you can use <code>pip</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install glslt
</span></span></code></pre></div><p>If you downloaded the source and want to build the latest version of the Python
module, use <code>maturin</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># Install maturin (only needed once)</span>
</span></span><span style=display:flex><span>pip install maturin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Assuming you are in a virtualenv</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>cd</span> glslt <span style=color:#ff79c6>&amp;&amp;</span> maturin develop --cargo-extra-args<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;--features python&#39;</span> -b pyo3<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><h2 id=usage>
Usage
<a class=heading-link href=#usage>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><h3 id=static-template-function-parameters>
Static template function parameters
<a class=heading-link href=#static-template-function-parameters>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p><code>glslt</code> supports <em>static template function parameters</em>. This means, passing the
name of an already-declared function as a parameter for a templated function.
Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>#version 460 core</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// A pointer to a function that has no args and returns an int</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// We use function prototypes for this matter since they&#39;re</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// basically useless in GLSL. Since there can be no indirect</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// recursion, there is no need for function pre-declarations.</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> intfn();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// A first function that could be an intfn</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> fnReturnsOne() { <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// A second function that could be an intfn</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> fnReturnsTwo() { <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>2</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// A template function. It&#39;s recognized as a template because it uses intfn</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// which has been declared as a function pointer.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// In the generated code, there will be no function called fnTemplate, as all</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// calls to fnTemplate will be replaced with template specializations.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Thus, callback can only be an identifier of an existing function, which</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// should (later: must with type-checking) match the pointer type</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> fnTemplate(<span style=color:#ff79c6>in</span> intfn callback) { <span style=color:#ff79c6>return</span> callback(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Calling fnTemplate with function pointers</span>
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>vec4</span>(fnTemplate(fnReturnsOne), fnTemplate(fnReturnsTwo), <span style=color:#bd93f9>0.</span>, <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that we do not define a new syntax. Instead, we use the function
pre-declaration syntax which is rarely used to declare function pointers. Thus,
all your existing tooling still works with <code>glslt</code>.</p><p>In order to run this code on your GPU, you need to process it so function
templates are <em>instantiated</em> with their actual template parameters. This is
where this tool comes in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># Assuming you installed the pre-built glsltc binary, if running from source use `cargo run --` instead.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># test.glsl is our input example, output.glsl is the generated code.</span>
</span></span><span style=display:flex><span>glsltc -o output.glsl test.glsl
</span></span></code></pre></div><p>The resulting code will look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>#version 460 core</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> fnReturnsOne() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> fnReturnsTwo() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> _glslt_fnTemplate_dd5173() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fnReturnsOne();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>int</span> _glslt_fnTemplate_4314fd() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fnReturnsTwo();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> main() {
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(_glslt_fnTemplate_dd5173(), _glslt_fnTemplate_4314fd(), <span style=color:#bd93f9>0.</span>, <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note how the template function calls have been replaced by regular GLSL
functions. This code can be directly used in an OpenGL application.</p><h3 id=lambda-template-function-parameters>
Lambda template function parameters
<a class=heading-link href=#lambda-template-function-parameters>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p><code>glslt</code> also supports <em>lambda template function parameters</em>. Instead of passing
a function name as a parameter to the templated function, you may pass an
expression. This expression may capture local variables and parameters, which
will be taken into account when instantiating the template. Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>float</span> sdf3d(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> opElongate(<span style=color:#ff79c6>in</span> sdf3d primitive, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> primitive(q);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(opElongate(sdSphere(_1, <span style=color:#bd93f9>4.</span>), <span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>))), <span style=color:#bd93f9>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note how instead of just passing <code>sdSphere</code> as a template parameter, we pass
<code>sdSphere(_1, 4.)</code>. This translates to calling <code>sdSphere</code> with the first
parameter given by the template function <code>opElongate</code>, while the second
parameter is the constant <code>4.</code>. This results in the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> _glslt_opElongate_d20939(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> sdSphere(q, <span style=color:#bd93f9>4.</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(_glslt_opElongate_d20939(<span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>))), <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since captures are supported, this example may have been written with the
sphere diameter being a parameter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>float</span> sdf3d(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> opElongate(<span style=color:#ff79c6>in</span> sdf3d primitive, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> primitive(q);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>float</span> sz <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5.</span>;
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(opElongate(sdSphere(_1, sz), <span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>))), <span style=color:#bd93f9>1.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//                                            ^^</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Using a local variable in the template argument</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The variable is properly captured in the generated code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// _glslt_lp2 is the captured variable input</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> _glslt_opElongate_d9170f(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h, <span style=color:#ff79c6>float</span> _glslt_lp2) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> sdSphere(q, _glslt_lp2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>float</span> sz <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5.</span>;
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(_glslt_opElongate_d9170f(<span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>), sz)), <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//                                                                 Captured variable: ^^</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=named-placeholders>
Named placeholders
<a class=heading-link href=#named-placeholders>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h4><p>When passing a lambda expression to a template function, you may use the
unnamed placeholders <code>_1</code>, <code>_2</code>, etc. to refer to the first, second, etc.
arguments to the template function call. You may also use the parameter names
as declared in the function prototype. The previous example could be written as
follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#6272a4>// In sdf3d template parameters, `p` is the first parameter name</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> sdf3d(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> opElongate(<span style=color:#ff79c6>in</span> sdf3d primitive, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> primitive(q);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(opElongate(sdSphere(_p, <span style=color:#bd93f9>1.0</span>), <span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>))), <span style=color:#bd93f9>1.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>//                                        ^^</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Named placeholder parameter in a template instead of _1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The generated code will look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#ff79c6>float</span> sdSphere(<span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>float</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> length(p) <span style=color:#ff79c6>-</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>float</span> _glslt_opElongate_784a47(<span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> p, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec3</span> h) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>vec3</span> q <span style=color:#ff79c6>=</span> p <span style=color:#ff79c6>-</span> clamp(p, <span style=color:#ff79c6>-</span>h, h);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> sdSphere(q, <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>void</span> mainImage(<span style=color:#ff79c6>out</span> <span style=color:#ff79c6>vec4</span> fragColor, <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>vec2</span> fragCoord) {
</span></span><span style=display:flex><span>    fragColor <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>vec4</span>(<span style=color:#ff79c6>vec3</span>(_glslt_opElongate_784a47(<span style=color:#ff79c6>vec3</span>(fragCoord, <span style=color:#bd93f9>0.</span>), <span style=color:#ff79c6>vec3</span>(<span style=color:#bd93f9>1.</span>, <span style=color:#bd93f9>2.</span>, <span style=color:#bd93f9>3.</span>))), <span style=color:#bd93f9>1.</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=nested-lambda-expressions>
Nested lambda expressions
<a class=heading-link href=#nested-lambda-expressions>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p>Nested lambda expressions are supported, however due to the syntax being used,
we have to make a decision on how to resolve the anonymous placeholders to
their corresponding lambda. The current algorithm transforms innermost lambdas
first, so the placeholders will resolve to the most nested expression first.</p><p>This may be circumvented by using named placeholders (as long as there is no
conflict) since undefined identifiers are passed as-is to the other passes of
the transformation algorithm, and thus, to outer lambdas.</p><h3 id=support-for-include-directives>
Support for include directives
<a class=heading-link href=#support-for-include-directives>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p><code>#include</code> directives are supported and will be processed, using the same rules
as C preprocessors: double-quoted paths will be looked up from the current file
being parsed. Angle-quoted paths will be looked up from the system include
paths.</p><h3 id=minifying-mode>
Minifying mode
<a class=heading-link href=#minifying-mode>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p>In its default mode, the GLSLT compiler will copy all input declarations to its
output (except function prototypes) and insert instantiated templates right
before they are used.</p><p>However, if you are using the GLSLT compiler with a large template library,
this will generate a lot of unused code. By using the <code>-K, --keep-fns</code> argument
to the <code>glsltc</code> command, GLSLT switches to the minifying mode. In this mode,
only the functions, types, and globals that are transitive dependencies of the
functions specified by the <code>-K</code> argument are kept.</p><p><code>#version</code>, <code>#extension</code> and precision specifiers will be included at the top
of the generated code, if they were present in the input.</p><p>As an example, compiling the previous example with <code>glsltc -K=sdSphere</code> will
only return the code for the sdSphere function, since it has no dependencies.</p><h2 id=features>
Features
<a class=heading-link href=#features>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><ul>
<li><input checked disabled type=checkbox> Include support</li><li><input disabled type=checkbox> Preserve comments in original source</li><li><input disabled type=checkbox> Report position in compiler errors</li><li><input checked disabled type=checkbox> Lambda template function parameters</li><li><input checked disabled type=checkbox> Static template function parameters</li></ul><h2 id=bindings>
Bindings
<a class=heading-link href=#bindings>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><h3 id=rust>
Rust
<a class=heading-link href=#rust>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p>Since this tool is developed in Rust, the <em>native</em> bindings are exposed as the
<code>glslt</code> Rust crate and can be used directly by client code.</p><h3 id=python>
Python
<a class=heading-link href=#python>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h3><p>The main library exposes a native Python 3 module using
<a href=https://pyo3.rs/ target=_blank rel=noopener>pyo3</a>. Use <a href=https://github.com/PyO3/maturin target=_blank rel=noopener>maturin</a> to
build and develop the Python module, inside a virtualenv.</p><p>In order to build the Python package, you have to enable the <code>python</code> feature
and have <code>python3-dev</code> installed. See the documentation for <a href=https://github.com/vtavernier/glslt/blob/master/glslt/ target=_blank rel=noopener>glslt</a> for
an example.</p><h2 id=limitations>
Limitations
<a class=heading-link href=#limitations>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><p>This program is based on the <a href=https://github.com/vtavernier/glsl-lang target=_blank rel=noopener>glsl-lang</a>
crate for parsing and manipulating the GLSL AST in Rust. However, since it&rsquo;s
only an AST and not a full parse tree, we have currently no way of preserving
original formatting. Comments are still parsed and are available to library
users, but they are not currently included in the output.</p><h2 id=author>
Author
<a class=heading-link href=#author>
<i class="fa fa-link" aria-hidden=true></i>
</a>
</h2><p>Vincent Tavernier <a href=https://github.com/vtavernier/glslt/blob/master/mailto:vince.tavernier@gmail.com target=_blank rel=noopener>vince.tavernier@gmail.com</a></p></article></section></div><footer class=footer>
<section class=container>
©
2019 -
2022
Vincent Tavernier
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.
</section></footer></main><script src=/js/coder.min.617ac1196e51a8e5820c29ea3f349ae87be7db1242a5a91f3afa569275213d0f.js integrity="sha256-YXrBGW5RqOWCDCnqPzSa6Hvn2xJCpakfOvpWknUhPQ8="></script>
<script src=/main.min.d2d1e601897e7d550d453590ae2ba709fcb5997a42c921151e8a64f7928a38af.js integrity="sha256-0tHmAYl+fVUNRTWQriunCfy1mXpCySEVHopk95KKOK8="></script>
<script data-goatcounter=https://vtavernier.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
</body></html>